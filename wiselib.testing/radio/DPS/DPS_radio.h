/********************************
*******************************************
 ** This file is part of the generic algorithm library Wiselib.           **
 ** Copyright (C) 2008,2009 by the Wisebed (www.wisebed.eu) project.      **
 **                                                                       **
 ** The Wiselib is free software: you can redistribute it and/or modify   **
 ** it under the terms of the GNU Lesser General Public License as        **
 ** published by the Free Software Foundation, either version 3 of the    **
 ** License, or (at your option) any later version.                       **
 **                                                                       **
 ** The Wiselib is distributed in the hope that it will be useful,        **
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of        **
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
 ** GNU Lesser General Public License for more details.                   **
 **                                                                       **
 ** You should have received a copy of the GNU Lesser General Public      **
 ** License along with the Wiselib.                                       **
 ** If not, see <http://www.gnu.org/licenses/>.                           **
 ***************************************************************************/

/*
* File: DPS_radio.h
* Class(es): 
* Author: Daniel Gehberger - GSoC 2013 - DPS project
*/

#ifndef __RADIO_DPS_RADIO_H__
#define __RADIO_DPS_RADIO_H__

#include "config_testing.h"

#include "util/delegates/delegate.hpp"
#include "util/pstl/vector_static.h"
#include "util/pstl/map_static_vector.h"
#include "util/pstl/pair.h"

#include "radio/DPS/DPS_config.h"
#include "radio/DPS/DPS_packet.h"



namespace wiselib
{
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Connection_t
	{
		typedef Radio_P Radio;
		typedef typename Radio::node_id_t node_id_t;
		
	public:
		Connection_t()
		: Pid(0),
		partner_MAC( Radio::NULL_NODE_ID ),
		connection_status(UNUSED),
		client_counter(0),
		server_counter(0),
		elapsed_time(0)
		{}
		
		enum connection_status
		{
			//Client
			UNUSED = 0,
			SENDING_DISCOVERY = 1,
			CONNECT_SENT = 2,
			
			//Server
			ADVERTISE_SENT = 4,
			ALLOW_SENT = 5,
			
			CONNECTED = 6
		};
		
		
		/**
		 * Protocol ID pair
		 */
		uint8_t Pid;
		
		/**
		 * MAC address of the communication partner (server/client)
		 */
		node_id_t partner_MAC;
		
		/**
		 * Status of the DPS connection
		 */
		uint8_t connection_status;
		
		/**
		 * CNT the Client
		 */
		uint32_t client_counter;
		
		/**
		 * CNT of the server
		 */
		uint32_t server_counter;
		
		/**
		 * Elapsed time since the last activity
		 */
		uint16_t elapsed_time;
		
		/**
		 * Nonce for the connection, generated by the client in the CONNECT message
		 */
		uint32_t connection_nonce;
// 		
// 		/**
// 		 * Connection keys (nonce XOR negotiated key)
// 		 */
// 		uint8_t my_connection_key[16];
// 		uint8_t partner_connection_key[16];
		
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Protocol_t
	{
		typedef Radio_P Radio;
		typedef typename Radio::node_id_t node_id_t;
		typedef typename Radio::block_data_t block_data_t;
		
	public:
		Protocol_t()
		: server( false ),
		rpc_handler_delegate(RPC_handler_delegate_t())
		{}
		
		/**
		 * Server / Client flag
		 */
		bool server;
		
		/**
		 * RPC_handler delegate
		 * Source, Fid, length, buffer
		 */
		typedef delegate4<int, node_id_t, uint8_t, uint16_t, block_data_t*> RPC_handler_delegate_t;
		RPC_handler_delegate_t rpc_handler_delegate;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
		
		
	/**
	* \brief DPS radio
	*/
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	class DPS_Radio
	{
	public:
		typedef OsModel_P OsModel;
		typedef Radio_P Radio;
		typedef Debug_P Debug;
		typedef Timer_P Timer;
		typedef Rand_P Rand;
		
		typedef DPS_Radio<OsModel, Radio, Debug, Timer, Rand> self_type;
		typedef self_type* self_pointer_t;
		
		typedef typename Radio::node_id_t node_id_t;
		typedef typename Radio::size_t size_t;
		typedef typename Radio::block_data_t block_data_t;
		typedef typename Radio::message_id_t message_id_t;
		
		typedef DPS_Packet<OsModel, Radio, Debug> DPS_Packet_t;
		
		typedef Protocol_t<Radio> protocol_type;
		typedef wiselib::pair<uint8_t, protocol_type> newprotocol_t;
		typedef MapStaticVector<OsModel, uint8_t, protocol_type, DPS_MAX_PROTOCOLS> Protocol_list_t;
		
		typedef Connection_t<Radio> connection_type;
		typedef vector_static<OsModel, connection_type, DPS_MAX_CONNECTIONS> Connection_list_t;
		typedef typename Connection_list_t::iterator Connection_list_iterator;
		
		//TODO
		enum Pid_values
		{
			TEST_PID = 10
		};

		// --------------------------------------------------------------------
		enum ErrorCodes
		{
			SUCCESS = OsModel::SUCCESS,
			ERR_UNSPEC = OsModel::ERR_UNSPEC,
			ERR_NOTIMPL = OsModel::ERR_NOTIMPL,
			ERR_HOSTUNREACH = OsModel::ERR_HOSTUNREACH
		};
		// --------------------------------------------------------------------
		
		enum SpecialNodeIds {
		BROADCAST_ADDRESS = Radio_P::BROADCAST_ADDRESS, ///< All nodes in communication range
		NULL_NODE_ID      = Radio_P::NULL_NODE_ID      ///< Unknown/No node id
		};
		
		// --------------------------------------------------------------------
// 		//TODO reduce the size?
// 		enum Restrictions {
// 			MAX_MESSAGE_LENGTH = Radio::MAX_MESSAGE_LENGTH  ///< Maximal number of bytes in payload
// 		};
		// --------------------------------------------------------------------
		///@name Construction / Destruction
		///@{
		DPS_Radio();
		~DPS_Radio();
		///@}
		
		int init( Radio& radio, Debug& debug, Timer& timer, Rand& rand )
		{
			radio_ = &radio;
			debug_ = &debug;
			timer_ = &timer;
			rand_ = &rand;
			
			return SUCCESS;
		}
		
		inline int init();
		inline int destruct();
		
		///@name Routing Control
		///@{
		int enable_radio( void );
		int disable_radio( void );
		///@}
		
		///@name Radio Concept
		///@{
		/**
		*/
		int send( node_id_t receiver, uint16_t length, block_data_t *data );
		
		/**
		 * \brief
		*/
		void receive( node_id_t from, size_t length, block_data_t *data );
		
		/**
		 * \brief
		*/
		node_id_t id()
		{
			return radio().id();
		}
		///@}
		
		/**
		 * \brief
		 */
		int send_connection_message( node_id_t destination, uint8_t type, connection_type* connection );
		
		/**
		 * \brief Function called by the timer in order to send DISCOVERY message
		 */
		void send_DISCOVERY( void* iterator );
		
		/**
		 * \brief
		 */
		template<class T, int (T::*TMethod)(node_id_t, uint8_t, uint16_t, block_data_t*)>
		int reg_recv_callback( T *obj_pnt, uint8_t Pid, bool server )
		{
			//The Pid has been already registered
			if( protocol_list_.contains( Pid ) )
				return ERR_UNSPEC;
			
			//Save the registration: function pointer and server flag
			newprotocol_t newprotocol;
			newprotocol.first = Pid;
			newprotocol.second.rpc_handler_delegate = protocol_type::RPC_handler_delegate_t::template from_method<T, TMethod>( obj_pnt );
			newprotocol.second.server = server;
			
			protocol_list_.push_back(newprotocol);
			
			#ifdef DPS_RADIO_DEBUG
			debug().debug( "DPS: RPC handler registration for %i at %llx as %x", Pid, (long long unsigned)(radio().id()), server);
			#endif
			
			//Start the DISCOVERY if it is a client
			if( !server )
			{
				connection_type connection;
				connection.Pid = Pid;
				connection.connection_status = connection_type::SENDING_DISCOVERY;
				connection.client_counter = rand()() % (0xFFFFFFFF);
				
				Connection_list_iterator it = connection_list_.insert( connection );
				
				if( it == connection_list_.end() )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug("DPS: Error, connection list is full");
					#endif
					return ERR_UNSPEC;
				}
				
				timer().template set_timer<self_type, &self_type::send_DISCOVERY>( DPS_TIMER_DISCOVERY_FREQUENCY, this, (void*)(&(*it)) );
			}
			
			return SUCCESS;
		}
		
		/**
		 * \brief
		 */
		int unreg_recv_callback( uint8_t Pid )
		{
// 			protocol_list_[Pid].rpc_handler_delegate = protocol_type::RPC_handler_delegate_t();
			return SUCCESS;
		}
		
	private:
		
		/**
		 * Map for the registered protocols
		 */
		Protocol_list_t protocol_list_;
		
		/**
		 * List for the connections
		 */
		Connection_list_t connection_list_;
		
		//Stored callback_id for radio
		uint8_t callback_id_;
		
		Radio& radio()
		{ return *radio_; }
		
		Debug& debug()
		{ return *debug_; }
		
		Timer& timer()
		{ return *timer_; }
		
		Rand& rand()
		{ return *rand_; }
		
		typename Radio::self_pointer_t radio_;
		typename Debug::self_pointer_t debug_;
		typename Timer::self_pointer_t timer_;
		typename Rand::self_pointer_t rand_;
		
	};
	
	
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	DPS_Radio()
	: radio_ ( 0 ),
	debug_ ( 0 )
	{}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	~DPS_Radio()
	{
		disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	init( void )
	{
		if ( enable_radio() != SUCCESS )
			return ERR_UNSPEC;
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	destruct( void )
	{
		return disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	enable_radio( void )
	{
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS Radio: initialization at %llx", (long long unsigned)(radio().id()) );
		#endif
		
		radio().enable_radio();
		
		radio().template reg_recv_callback<self_type, &self_type::receive>( this );

		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	disable_radio( void )
	{
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS Radio: Disable" );
		#endif
		
		if( radio().disable_radio() != SUCCESS )
			return ERR_UNSPEC;
		radio().template unreg_recv_callback(callback_id_);
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_connection_message( node_id_t destination, uint8_t type, connection_type* connection )
	{
		//Create a packet, no fragmentation
		DPS_Packet_t packet( type, false );
		block_data_t* payload=packet.get_payload();
		
		//Set the common fields
		packet.set_pid( connection->Pid );
		packet.set_counter( connection->client_counter );
		
		if( type == DPS_Packet_t::DPS_TYPE_DISCOVERY || type == DPS_Packet_t::DPS_TYPE_ADVERTISE )
		{
			//TODO handle filters
// 			uint8_t number_of_filters = 0;
			payload[0] = 0; //number_of_filters;
			
			packet.length++;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST )
		{
			connection->connection_nonce = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload, connection->connection_nonce, 0, 32 );
			packet.length += 4;
			//TODO calculate K_conn for the client here
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW )
		{
			connection->server_counter = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload, connection->server_counter, 0, 32 );
			packet.length += 4;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH )
		{
			bitwise_write<OsModel, block_data_t, uint32_t>( payload, connection->server_counter, 0, 32 );
			packet.length += 4;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ABORT )
		{
			uint32_t dummy = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload, dummy, 0, 32 );
			packet.length += 4;
		}
		else
		{
			#ifdef DPS_RADIO_DEBUG
			debug().debug( "DPS: Error, unsupported type code for connection message");
			#endif
		}
		
		
		//TODO add the checksum
		
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS: send %x from %llx to %llx", type, (long long unsigned)(radio().id()), (long long unsigned)(destination));
		#endif
		
// 		packet.set_debug( *debug_ );
// 		packet.print_header();
		
		radio().send( destination, packet.length, packet.buffer );
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send( node_id_t destination, uint16_t length, block_data_t *data )
	{
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	receive( node_id_t from, size_t length, block_data_t *data ) 
	{
		
		DPS_Packet_t packet( length, data );
		block_data_t* payload=packet.get_payload();
		
// 		packet.set_debug( *debug_ );
// 		packet.print_header();
		
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS: Node %llx received from %llx, packet type: %i ", (long long unsigned)(radio().id()), (long long unsigned)(from), packet.type());
		#endif
		//------------ Handle connection message types ------------
		
		//Receive a Discovery at a node which provides the protocol as a server
		if( packet.type() == DPS_Packet_t::DPS_TYPE_DISCOVERY 
			&& protocol_list_.contains(packet.pid()) && protocol_list_.find(packet.pid())->second.server )
		{
			//TODO handle filters
			
			//Check whether there has been a connection already established with this client
			for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			{
				if( it->Pid == packet.pid() && it->partner_MAC == from )
					return;
			}
			
			connection_type connection;
			connection.Pid = packet.pid();
			connection.connection_status = connection_type::ADVERTISE_SENT;
			connection.client_counter = packet.counter();
			connection.partner_MAC = from;
			
			Connection_list_iterator it = connection_list_.insert( connection );
			
			if( it == connection_list_.end() )
			{
				#ifdef DPS_RADIO_DEBUG
				debug().debug("DPS: Error, connection list is full");
				#endif
				return;
			}
			
			send_connection_message( from, DPS_Packet_t::DPS_TYPE_ADVERTISE, &connection );
		}
		//The node can receive this only as a reply
		//TODO LQI based selection --> only store and make decision after some more time
		else if( packet.type() == DPS_Packet_t::DPS_TYPE_ADVERTISE ) //CLIENT CODE
			//&& protocol_list_.contains(packet.pid()) && protocol_list_.find(packet.pid())->second.client )
		{
			for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			{
				if( it->Pid == packet.pid() )
				{
					//Check for duplicate ADVERTISE messages
					if( it->partner_MAC != NULL_NODE_ID )
						return;
					
					//Reset the timer for the connection
					it->elapsed_time = 0;
					
					it->connection_status = connection_type::CONNECT_SENT;
					it->partner_MAC = from;
					
					//Send a CONNECT to the selected server 
					send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST, &(*it) );
					break;
				}
			}
		}
		else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ABORT)
		{
			//Search for the used connection
			for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			{
				if( it->Pid == packet.pid() && it->partner_MAC == from )
				{
					//Reset the timer for the connection
					it->elapsed_time = 0;
					
					if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //SERVER SIDE
					{
						//TODO check for available resources?
						it->connection_status = connection_type::ALLOW_SENT;
						it->connection_nonce = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
						//TODO calculate the K_conn keys
						
						send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW, &(*it) );
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ) //CLIENT SIDE
					{
						it->connection_status = connection_type::CONNECTED;
						it->server_counter = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
						
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: Client (%llx) connected to %llx, protocol: %i", (long long unsigned)(radio().id()), (long long unsigned)(from), it->Pid);
						debug().debug( "DPS parameters CNT_c: %llx, CNT_s: %llx, nonce: %llx", (long long unsigned)(it->client_counter), (long long unsigned)(it->server_counter), (long long unsigned)(it->connection_nonce) );
						#endif
						
						send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_FINISH, &(*it) );
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ) //SERVER SIDE
					{
						it->connection_status = connection_type::CONNECTED;
						
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: Server (%llx) connected to %llx, protocol: %i", (long long unsigned)(radio().id()), (long long unsigned)(from), it->Pid);
						debug().debug( "DPS parameters CNT_c: %llx, CNT_s: %llx, nonce: %llx", (long long unsigned)(it->client_counter), (long long unsigned)(it->server_counter), (long long unsigned)(it->connection_nonce) );
						#endif
					}
					else //DPS_Packet_t::DPS_TYPE_CONNECT_ABORT
					{
						connection_list_.erase( it );
					}
				}
			}
		}
		else
		{
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_DISCOVERY( void* c )
	{
		connection_type* conn = (connection_type*)c;
		
		send_connection_message( Radio::BROADCAST_ADDRESS, DPS_Packet_t::DPS_TYPE_DISCOVERY, conn );
		
		//NOTE may not the expected
		if( conn->connection_status == connection_type::SENDING_DISCOVERY )
		{
			conn->elapsed_time += DPS_TIMER_DISCOVERY_FREQUENCY;
			timer().template set_timer<self_type, &self_type::send_DISCOVERY>( DPS_TIMER_DISCOVERY_FREQUENCY, this, conn );
		}
	}
	
}
#endif
