/***************************************************************************
 ** This file is part of the generic algorithm library Wiselib.           **
 ** Copyright (C) 2008,2009 by the Wisebed (www.wisebed.eu) project.      **
 **                                                                       **
 ** The Wiselib is free software: you can redistribute it and/or modify   **
 ** it under the terms of the GNU Lesser General Public License as        **
 ** published by the Free Software Foundation, either version 3 of the    **
 ** License, or (at your option) any later version.                       **
 **                                                                       **
 ** The Wiselib is distributed in the hope that it will be useful,        **
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of        **
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
 ** GNU Lesser General Public License for more details.                   **
 **                                                                       **
 ** You should have received a copy of the GNU Lesser General Public      **
 ** License along with the Wiselib.                                       **
 ** If not, see <http://www.gnu.org/licenses/>.                           **
 ***************************************************************************/

/*
* File: DPS_radio.h
* Class(es): 
* Author: Daniel Gehberger - GSoC 2013 - DPS project
*/

#ifndef __RADIO_DPS_RADIO_H__
#define __RADIO_DPS_RADIO_H__

#include "config_testing.h"

#include "util/delegates/delegate.hpp"
#include "util/pstl/vector_static.h"
#include "util/pstl/map_static_vector.h"
#include "util/pstl/pair.h"

#include "radio/DPS/DPS_config.h"
#include "radio/DPS/DPS_packet.h"



namespace wiselib
{
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Connection_t
	{
		typedef Radio_P Radio;
		typedef typename Radio::node_id_t radio_node_id_t;
		
	public:
		Connection_t()
		: partner_MAC( Radio::NULL_NODE_ID ),
		client_counter(0),
		server_counter(0),
		connection_nonce(0),
		elapsed_time(0),
		link_metric(0xFFFF),
		Pid(0),
		connection_status(UNUSED)
		{}
		
		enum connection_status
		{
			//Client
			UNUSED = 0,
			SENDING_DISCOVERY = 1,
			CONNECT_SENT = 2,
			
			//Server
			ADVERTISE_SENT = 4,
			ALLOW_SENT = 5,
			
			CONNECTED = 6
		};
		
		/**
		 * MAC address of the communication partner (server/client)
		 */
		radio_node_id_t partner_MAC;
		
		/**
		 * CNT the Client
		 */
		uint32_t client_counter;
		
		/**
		 * CNT of the server
		 */
		uint32_t server_counter;
		
		/**
		 * Nonce for the connection, generated by the client in the CONNECT message
		 */
		uint32_t connection_nonce;
		
		/**
		 * Elapsed time since the last activity
		 */
		uint16_t elapsed_time;
		
		/**
		 * The link metric for the actual connection, only used at connection setup at the moment
		 */
		uint16_t link_metric;
		
		/**
		 * Connection keys (nonce XOR negotiated key)
		 */
		uint8_t key[16];
// 		uint8_t my_connection_key[16];
// 		uint8_t partner_connection_key[16];
		
		/**
		 * Protocol ID pair
		 */
		uint8_t Pid;
		
		/**
		 * Status of the DPS connection
		 */
		uint8_t connection_status;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	class DPS_node_id_type
	{
	public:
		DPS_node_id_type()
		: Pid( 0 ),
		Fid( 0 ),
		ack_required( 0 )
		{}
		
		uint8_t Pid;
		uint8_t Fid;
		uint8_t ack_required;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Protocol_t
	{
		typedef Radio_P Radio;
		typedef DPS_node_id_type node_id_t;
		typedef typename Radio::block_data_t block_data_t;
		
	public:
		Protocol_t()
		: server( false ),
		rpc_handler_delegate(RPC_handler_delegate_t()),
		buffer_handler_delegate(buffer_handler_delegate_t())
		{}
		
		/**
		 * Server / Client flag
		 */
		bool server;
		
		/**
		 * RPC_handler delegate
		 * Source, Fid, length, buffer
		 */
		typedef delegate3<int, node_id_t, uint16_t, block_data_t*> RPC_handler_delegate_t;
		RPC_handler_delegate_t rpc_handler_delegate;
		
		/**
		 * buffer handler delegate
		 * function for 2 use cases
		 * 	- get a buffer for incoming messages
		 * 	- when ACK is required then free up the buffer
		 */
		typedef delegate3<block_data_t*, block_data_t*, uint16_t, bool> buffer_handler_delegate_t;
		buffer_handler_delegate_t buffer_handler_delegate;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P,
		typename Connection_list_iterator_P>
	class buffer_list_type
	{
		typedef Radio_P Radio;
		typedef DPS_node_id_type node_id_t;
		typedef Connection_list_iterator_P Connection_list_iterator;
		typedef typename Radio::block_data_t block_data_t;
		
	public:
		buffer_list_type()
		: buffer_pointer( NULL ),
		connection_it( NULL ),
		RPC_parameters(),
		processed_size( 0 ),
		last_fragment_size( 0 ),
		elapsed_time( 0 ),
		buffer_length( 0 ),
		outgoing( true )
		{}
		
		/**
		 */
		block_data_t* buffer_pointer;
		
		/**
		 */
		Connection_list_iterator connection_it;
		
		/**
		 */
		node_id_t RPC_parameters;
		
		/**
		 */
		uint16_t processed_size;
		
		/**
		 */
		uint16_t last_fragment_size;
		
		/**
		 */
		uint16_t elapsed_time;
		
		/**
		 */
		uint16_t buffer_length;
		
		/**
		 */
		bool outgoing;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
		
		
	/**
	* \brief DPS radio
	*/
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	class DPS_Radio
	{
	public:
		typedef OsModel_P OsModel;
		typedef Radio_P Radio;
		typedef Debug_P Debug;
		typedef Timer_P Timer;
		typedef Rand_P Rand;
		
		typedef DPS_Radio<OsModel, Radio, Debug, Timer, Rand> self_type;
		typedef self_type* self_pointer_t;
		
		typedef typename Radio::node_id_t radio_node_id_t;
		typedef typename Radio::size_t size_t;
		typedef typename Radio::block_data_t block_data_t;
		typedef typename Radio::message_id_t message_id_t;
		typedef typename Radio::ExtendedData ExtendedData;
		
		//node_id_t as a triplet: P_id, F_id, ack_flag
		typedef DPS_node_id_type node_id_t;
		
		typedef Protocol_t<Radio> protocol_type;
		typedef wiselib::pair<uint8_t, protocol_type> newprotocol_t;
		typedef MapStaticVector<OsModel, uint8_t, protocol_type, DPS_MAX_PROTOCOLS> Protocol_list_t;
		
		typedef Connection_t<Radio> connection_type;
		typedef vector_static<OsModel, connection_type, DPS_MAX_CONNECTIONS> Connection_list_t;
		typedef typename Connection_list_t::iterator Connection_list_iterator;
		
		typedef buffer_list_type<Radio, Connection_list_iterator> buffer_element_t;
		typedef vector_static<OsModel, buffer_element_t, DPS_MAX_BUFFER_LIST> Buffer_list_t;
		typedef typename Buffer_list_t::iterator Buffer_list_iterator;
		
		typedef DPS_Packet<OsModel, Radio, Debug, Connection_list_iterator> DPS_Packet_t;
		
		//TODO
		enum Pid_values
		{
			TEST_PID = 10
		};

		// --------------------------------------------------------------------
		enum ErrorCodes
		{
			SUCCESS = OsModel::SUCCESS,
			ERR_UNSPEC = OsModel::ERR_UNSPEC,
			ERR_NOTIMPL = OsModel::ERR_NOTIMPL,
			ERR_HOSTUNREACH = OsModel::ERR_HOSTUNREACH,
			NO_CONNECTION = 100
		};
		// --------------------------------------------------------------------
		
		enum SpecialNodeIds {
		BROADCAST_ADDRESS = Radio_P::BROADCAST_ADDRESS, ///< All nodes in communication range
		NULL_NODE_ID      = Radio_P::NULL_NODE_ID      ///< Unknown/No node id
		};
		
		// --------------------------------------------------------------------
// 		//TODO reduce the size?
// 		enum Restrictions {
// 			MAX_MESSAGE_LENGTH = Radio::MAX_MESSAGE_LENGTH  ///< Maximal number of bytes in payload
// 		};
		// --------------------------------------------------------------------
		///@name Construction / Destruction
		///@{
		DPS_Radio();
		~DPS_Radio();
		///@}
		
		int init( Radio& radio, Debug& debug, Timer& timer, Rand& rand )
		{
			radio_ = &radio;
			debug_ = &debug;
			timer_ = &timer;
			rand_ = &rand;
			
// 			rand_->srand( id() );
			
			return SUCCESS;
		}
		
		inline int init();
		inline int destruct();
		
		///@name Routing Control
		///@{
		int enable_radio( void );
		int disable_radio( void );
		///@}
		
		///@name Radio Concept
		///@{
		/**
		*/
		int send( node_id_t receiver, uint16_t length, block_data_t *data );
		
		/**
		 * \brief
		*/
		void receive( radio_node_id_t from, size_t length, block_data_t *data,  ExtendedData const &ex );
		
		/**
		 * \brief
		*/
		radio_node_id_t id()
		{
			return radio().id();
		}
		///@}
		
		
		
		/**
		 * \brief
		 */
		template<class T, int (T::*TMethod)(node_id_t, uint16_t, block_data_t*), block_data_t* (T::*TMethod2)(block_data_t*, uint16_t, bool)>
		int reg_recv_callback( T *obj_pnt, uint8_t Pid, bool server )
		{
			//The Pid has been already registered
			if( protocol_list_.contains( Pid ) )
				return ERR_UNSPEC;
			
			//Save the registration: function pointer and server flag
			newprotocol_t newprotocol;
			newprotocol.first = Pid;
			newprotocol.second.rpc_handler_delegate = protocol_type::RPC_handler_delegate_t::template from_method<T, TMethod>( obj_pnt );
			newprotocol.second.buffer_handler_delegate = protocol_type::buffer_handler_delegate_t::template from_method<T, TMethod2>( obj_pnt );
			newprotocol.second.server = server;
			
			protocol_list_.push_back(newprotocol);
			
			#ifdef DPS_RADIO_DEBUG
			debug().debug( "DPS: RPC handler registration for %i at %llx as %x", Pid, (long long unsigned)(radio().id()), server);
			#endif
			
			//Start the DISCOVERY if it is a client
			if( !server )
			{
				connection_type connection;
				connection.Pid = Pid;
				connection.connection_status = connection_type::SENDING_DISCOVERY;
				connection.client_counter = rand()() % (0xFFFFFFFF);
				
				Connection_list_iterator it = connection_list_.insert( connection );
				
				if( it == connection_list_.end() )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug("DPS: Error, connection list is full");
					#endif
					return ERR_UNSPEC;
				}
				
				timer().template set_timer<self_type, &self_type::send_DISCOVERY>( DPS_TIMER_DISCOVERY_FREQUENCY, this, (void*)(it-connection_list_.begin()) );
			}
			
			return SUCCESS;
		}
		
		/**
		 * \brief
		 */
		int unreg_recv_callback( uint8_t Pid )
		{
// 			protocol_list_[Pid].rpc_handler_delegate = protocol_type::RPC_handler_delegate_t();
			return SUCCESS;
		}
		
	private:
		
		/**
		* \brief
		*/
		void send_RPC( Buffer_list_iterator act_buffer );
		
		/**
		* \brief
		*/
		int send_connection_message( radio_node_id_t destination, uint8_t type, Connection_list_iterator connection );
		
		/**
		* \brief Function called by the timer in order to send DISCOVERY message
		*/
		void send_DISCOVERY( void* n_in );
		
		/**
		 * \brief Function called by the timer in order to send CONNECT message
		 */
		void request_connection( void* n_in );
		
		/**
		* \brief Function called by the timer in order to mentain timing in DPS
		*/
		void general_periodic_timer( void* );
		
		/**
		 * \brief Calculate the connection key
		 * NOTE: The nonce must be set for the connection when this function is called.
		 */
		void generate_connection_key( Connection_list_iterator connection );
		
		//NOTE: only for TEST
		void turn_off( void* )
		{
			//disable_radio(); is not working for shawn...
			disabled_ = true;
		}
		
		bool disabled_;
		
		/**
		 * Map for the registered protocols
		 */
		Protocol_list_t protocol_list_;
		
		/**
		 * List for the connections
		 */
		Connection_list_t connection_list_;
		
		/**
		 * List for the in/outgoing contents
		 */
		Buffer_list_t buffer_list_;
		
		
		//Stored callback_id for radio
		uint8_t callback_id_;
		
		Radio& radio()
		{ return *radio_; }
		
		Debug& debug()
		{ return *debug_; }
		
		Timer& timer()
		{ return *timer_; }
		
		Rand& rand()
		{ return *rand_; }
		
		typename Radio::self_pointer_t radio_;
		typename Debug::self_pointer_t debug_;
		typename Timer::self_pointer_t timer_;
		typename Rand::self_pointer_t rand_;
		
	};
	
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	DPS_Radio()
	: radio_ ( 0 ),
	debug_ ( 0 )
	{}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	~DPS_Radio()
	{
		disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	init( void )
	{
		if ( enable_radio() != SUCCESS )
			return ERR_UNSPEC;
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	destruct( void )
	{
		return disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	enable_radio( void )
	{
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS Radio: initialization at %llx", (long long unsigned)(radio().id()) );
		#endif
		
		radio().enable_radio();
		
		radio().template reg_recv_callback<self_type, &self_type::receive>( this );
		
		//Start the periodic timer with an extra 2 sec delay in order to establish initial connections
		timer().template set_timer<self_type, &self_type::general_periodic_timer>( DPS_GENERAL_TIMER_FREQUENCY + 2000, this, NULL );
		
		
		//NOTE only for TEST
		disabled_ = false;
		if( id() == 0 )
			timer().template set_timer<self_type, &self_type::turn_off>( 8000, this, NULL );
		
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	disable_radio( void )
	{
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS Radio: Disable" );
		#endif
		
		if( radio().disable_radio() != SUCCESS )
			return ERR_UNSPEC;
		radio().template unreg_recv_callback(callback_id_);
		
		return SUCCESS;
	}
	
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	generate_connection_key( Connection_list_iterator connection )
	{
		//Key derivation
		memcpy(connection->key, DPS_REQUEST_KEY, 16);
		radio_node_id_t x, y;
		
		//Use a fixed order of the two addresses
		if( connection->partner_MAC > id() )
		{
			x = connection->partner_MAC;
			y = id();
		}
		else
		{
			x = id();
			y = connection->partner_MAC;
		}
		memcpy(&(connection->key[0]), &x, sizeof(radio_node_id_t));
		memcpy(&(connection->key[8]), &y, sizeof(radio_node_id_t));
		
		// XOR it with the connection_nonce
		for (uint8_t i=0; i<=12; i=i+4) {
			connection->key[i+0] ^= ((connection->connection_nonce >> 24) & 0xFF);
			connection->key[i+1] ^= ((connection->connection_nonce >> 16) & 0xFF);
			connection->key[i+2] ^= ((connection->connection_nonce >> 8) & 0xFF);
			connection->key[i+3] ^= ((connection->connection_nonce >> 0) & 0xFF);
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_connection_message( radio_node_id_t destination, uint8_t type, Connection_list_iterator connection )
	{
		
		//NOTE only for TEST
		if( disabled_ )
			return ERR_UNSPEC;
		
		//Create a packet, no fragmentation
		DPS_Packet_t packet( type, false );
		block_data_t* payload_act_pointer=packet.get_payload();
		
		//Set the common fields
		packet.set_pid( connection->Pid );
		packet.set_counter( connection->client_counter );
		
		bool use_requst_key_for_checksum = false;
		
		if( type == DPS_Packet_t::DPS_TYPE_HARTBEAT )
		{
			if( protocol_list_[connection->Pid].server )
			{
				packet.set_counter( connection->server_counter );
				connection->server_counter++;
			}
			else
			{
				connection->client_counter++;
			}
		}
		else if( type == DPS_Packet_t::DPS_TYPE_DISCOVERY || type == DPS_Packet_t::DPS_TYPE_ADVERTISE )
		{
			use_requst_key_for_checksum = true;
			
			//TODO handle filters
// 			uint8_t number_of_filters = 0;
			payload_act_pointer[0] = 0; //number_of_filters;
			
			payload_act_pointer++;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST )
		{
			connection->connection_nonce = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->connection_nonce, 0, 32 );
			payload_act_pointer += 4;
			
			//Generate the key for the connection based on the nonce
			generate_connection_key( connection );
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW )
		{
			connection->server_counter = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->server_counter, 0, 32 );
			payload_act_pointer += 4;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH )
		{
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->server_counter, 0, 32 );
			payload_act_pointer += 4;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ABORT )
		{
// 			uint32_t dummy = rand()() % (0xFFFFFFFF);
// 			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, dummy, 0, 32 );
			payload_act_pointer += 4;
		}
		else
		{
			#ifdef DPS_RADIO_DEBUG
			debug().debug( "DPS: Error, unsupported type code for connection message");
			#endif
		}
		
		//Calculate the full length
		packet.length += payload_act_pointer - packet.get_payload();
		
#if DPS_FOOTER > 0
		packet.set_checksum( connection, use_requst_key_for_checksum );
#endif
		
		
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS: send from %llx to %llx, packet type: %i", (long long unsigned)(radio().id()), (long long unsigned)(destination), type);
		#endif
		
// 		packet.set_debug( *debug_ );
// 		packet.print_header();

		//Reset the timer
		connection->elapsed_time = 0;

		radio().send( destination, packet.length, packet.buffer );
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send( node_id_t destination, uint16_t length, block_data_t *data )
	{
		//NOTE only for TEST
		if( disabled_ )
			return ERR_UNSPEC;
		
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
		{
			if( it->Pid == destination.Pid && it->connection_status == connection_type::CONNECTED )
			{
				if( buffer_list_.size() == DPS_MAX_BUFFER_LIST )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug( "DPS fatal: buffer list is full!" );
					#endif
					return ERR_UNSPEC;
				}
				
				buffer_element_t new_buffer;
				
				new_buffer.buffer_length = length;
				
				new_buffer.buffer_pointer = data;
				
				new_buffer.RPC_parameters = destination;
				
				new_buffer.connection_it = it;
				
				new_buffer.outgoing = true;
				
				Buffer_list_iterator act_buffer = buffer_list_.insert( new_buffer );
				
				send_RPC( act_buffer );
				
				return SUCCESS;
			}
		}
		return NO_CONNECTION;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
	typename Radio_P,
	typename Debug_P,
	typename Timer_P,
	typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_RPC( Buffer_list_iterator act_buffer )
	{
		act_buffer->elapsed_time = 0;
		
		bool fragmentation = false;
		
		//Check the size of the data: Max message size vs. header + payload + footer
		if( Radio::MAX_MESSAGE_LENGTH < act_buffer->buffer_length + DPS_Packet_t::DPS_RPC_HEADER_SIZE + DPS_Packet_t::DPS_FOOTER_SIZE )
			fragmentation = true;
		
		//Create a packet with or without fragmentation
		DPS_Packet_t packet( DPS_Packet_t::DPS_TYPE_RPC_REQUEST, fragmentation );
		
		packet.set_pid( act_buffer->RPC_parameters.Pid );
		packet.set_fid( act_buffer->RPC_parameters.Fid );
		packet.set_ack_flag( act_buffer->RPC_parameters.ack_required );
		
		if( protocol_list_[packet.pid()].server )
			packet.set_counter( act_buffer->connection_it->server_counter );
		else
			packet.set_counter( act_buffer->connection_it->client_counter );
		
		//execute the loop at least once
		bool more_to_send = true;
		while( more_to_send )
		{
		
			//Fill in the fragmentation header
			if( fragmentation )
			{
				//Full size of the RPC and the shift for this fragment
				packet.set_fragmentation_header( act_buffer->buffer_length, act_buffer->processed_size );
			}
			
			uint8_t act_payload_size;
			//Calculate the payload size for this DPS packet
			//If the remaining size (buffer_length-processed_size) is bigger than the max payload size
			if( packet.payload_max_length < act_buffer->buffer_length - act_buffer->processed_size)
				//Use the full available payload
				act_payload_size = packet.payload_max_length;
			else
				//else: only the required size
				act_payload_size = act_buffer->buffer_length - act_buffer->processed_size;
			
			//Copy the payload into the packet
			memcpy( packet.buffer + packet.length, act_buffer->buffer_pointer + act_buffer->processed_size, act_payload_size);
			packet.length += act_payload_size;
			
	#if DPS_FOOTER > 0
			packet.set_checksum( act_buffer->connection_it, false );
	#endif
			
			#ifdef DPS_RADIO_DEBUG
			if( fragmentation )
				debug().debug( "DPS: send RPC fragment (%i/%i) from %llx to %llx (%i/%i)", packet.fragmentation_header_length(), packet.fragmentation_header_shift(), (long long unsigned)(radio().id()), (long long unsigned)(act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
			else
				debug().debug( "DPS: send RPC from %llx to %llx (%i/%i)", (long long unsigned)(radio().id()), (long long unsigned)(act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
			#endif
			
			//Send the (fragment)
			radio().send( act_buffer->connection_it->partner_MAC, packet.length, packet.buffer );
			
			//Reset the timer
			act_buffer->connection_it->elapsed_time = 0;
			
			//Wait for the ACK, this function will be called again by the timeout/receive(ACK) if there are more fragments
			if( act_buffer->RPC_parameters.ack_required )
			{
				act_buffer->last_fragment_size = act_payload_size;
				more_to_send = false;
			}
			//Packet completed and no ACK
			else if( act_buffer->processed_size + act_payload_size == act_buffer->buffer_length )
			{
				//Free up the buffer
				(protocol_list_[act_buffer->RPC_parameters.Pid].buffer_handler_delegate)( act_buffer->buffer_pointer, act_buffer->buffer_length, false );
				
				more_to_send = false;
				
				//Sending completed, increment the counter
				if( protocol_list_[packet.pid()].server )
					act_buffer->connection_it->server_counter++;
				else
					act_buffer->connection_it->client_counter++;
				
				//remove from the list
				buffer_list_.erase( act_buffer );
			}
			//more fragments and no ack, reset the DPS packet length (RPC header + Frag header)
			else 
			{
				//Increase the processed size
				act_buffer->processed_size += act_payload_size;
				//reset the DPS packet
				packet.length = DPS_Packet_t::DPS_RPC_HEADER_SIZE + DPS_Packet_t::DPS_FRAGMENTATION_HEADER_SIZE;
			}
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	receive( radio_node_id_t from, size_t length, block_data_t *data, ExtendedData const &ex ) 
	{
		//The initial 2 bits must be: 10
		if( bitwise_read<OsModel, block_data_t, uint8_t>( data, 0, 2 ) != 2 )
			return;
		
		DPS_Packet_t packet( length, data );
		block_data_t* payload=packet.get_payload();
		
// 		packet.set_debug( *debug_ );
// 		packet.print_header();
		
		#ifdef DPS_RADIO_DEBUG
		debug().debug( "DPS: Node %llx received from %llx, packet type: %i ", (long long unsigned)(radio().id()), (long long unsigned)(from), packet.type());
		#endif
		//------------ Handle connection message types ------------
		
		if( packet.type() == DPS_Packet_t::DPS_TYPE_DISCOVERY || packet.type() == DPS_Packet_t::DPS_TYPE_ADVERTISE )
		{
#if DPS_FOOTER > 0
			//Checksum validation based on the REQUEST key
			if( !(packet.validate_checksum( connection_list_.end(), true )) )
			{
				#ifdef DPS_RADIO_DEBUG
				debug().debug( "DPS: checksum error in DISCOVERY/ADVERTISE packet" );
				#endif
				return;
			}
#endif
			//Receive a Discovery at a node which provides the protocol as a server
			if( packet.type() == DPS_Packet_t::DPS_TYPE_DISCOVERY && 
				protocol_list_.contains(packet.pid()) && protocol_list_[packet.pid()].server )
			{
				//TODO handle filters
				
				//Check whether there has been a connection already established with this client
				for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
				{
					if( it->Pid == packet.pid() && it->partner_MAC == from )
						return;
				}
				
				//Create the new connection entry and add to the list
				connection_type connection;
				connection.Pid = packet.pid();
				connection.connection_status = connection_type::ADVERTISE_SENT;
				connection.client_counter = packet.counter();
				connection.partner_MAC = from;
				
				Connection_list_iterator it = connection_list_.insert( connection );
				
				if( it == connection_list_.end() )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug("DPS: Error, connection list is full");
					#endif
					return;
				}
				
				send_connection_message( from, DPS_Packet_t::DPS_TYPE_ADVERTISE, it );
				return;
			}
			
			//The node can receive this only as a reply
			if( packet.type() == DPS_Packet_t::DPS_TYPE_ADVERTISE &&
				!(protocol_list_[packet.pid()].server) ) //CLIENT CODE
			{
				for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
				{
					if( it->Pid == packet.pid() )
					{
						//If the there is a connection  or the counter is incorrect, drop the message
						if( it->connection_status != connection_type::SENDING_DISCOVERY || it->client_counter != packet.counter() )
							return;
						
						//If this is a better candidate than the previous ones, based on the link metric
						if( it->link_metric > ex.link_metric() )
						{
							//If this was the first advertisement, wait some more time for a possible better candidate
							if( it->link_metric == 0xFFFF )
								timer().template set_timer<self_type, &self_type::request_connection>( DPS_WAIT_FOR_MORE_ADVERTISEMENTS_TIMEOUT, this, (void*)(it-connection_list_.begin()) );
							
							it->partner_MAC = from;
							it->link_metric = ex.link_metric();
							
							#ifdef DPS_RADIO_DEBUG
							debug().debug( "DPS: candidate (%llx) stored with link_metric: %i", (long long unsigned)(from), it->link_metric );
							#endif
						}
						
						return;
					}
				}
			}
		}
		else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ||
			 packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ABORT)
		{
			//Search for the used connection
			for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			{
				if( ( it->Pid == packet.pid() ) && ( it->partner_MAC == from ) && 
					( it->client_counter == packet.counter() ) && ( it->connection_status != connection_type::CONNECTED ) )
				{
					//CONNECTION_REQUEST must be pre-processed to calculate the key
					if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //SERVER SIDE
					{
						//TODO check for available resources?
						it->connection_status = connection_type::ALLOW_SENT;
						it->connection_nonce = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
						
						//Generate the key for the connection based on the nonce (iterator to pointer cast)
						generate_connection_key( it );
					}
					
#if DPS_FOOTER > 0
					//Checksum validation based on the connection key
					if( !(packet.validate_checksum( it, false )) )
					{
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: checksum error in CONNECTION packet" );
						#endif
						
						connection_list_.erase( it );
						return;
					}
#endif
					
					if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //SERVER SIDE
					{
						send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW, it );
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ) //CLIENT SIDE
					{
						it->connection_status = connection_type::CONNECTED;
						it->server_counter = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
						
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: Client (%llx) connected to %llx, protocol: %i", (long long unsigned)(radio().id()), (long long unsigned)(from), it->Pid);
						debug().debug( "DPS parameters CNT_c: %llx, CNT_s: %llx, nonce: %llx", (long long unsigned)(it->client_counter), (long long unsigned)(it->server_counter), (long long unsigned)(it->connection_nonce) );
						#endif
						
						send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_FINISH, it );
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ) //SERVER SIDE
					{
						it->connection_status = connection_type::CONNECTED;
						
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: Server (%llx) connected to %llx, protocol: %i", (long long unsigned)(radio().id()), (long long unsigned)(from), it->Pid);
						debug().debug( "DPS parameters CNT_c: %llx, CNT_s: %llx, nonce: %llx", (long long unsigned)(it->client_counter), (long long unsigned)(it->server_counter), (long long unsigned)(it->connection_nonce) );
						#endif
					}
					else //DPS_Packet_t::DPS_TYPE_CONNECT_ABORT
					{
						connection_list_.erase( it );
					}
					return;
				}
			}
			
			#ifdef DPS_RADIO_DEBUG
			debug().debug( "DPS: Error, (%llx) received connection message from %llx without matching conn. entry!", (long long unsigned)(radio().id()), (long long unsigned)(from));
			#endif
		}
		//Messages with CONNECTED status
		else
		{
			for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			{
				if( ( it->Pid == packet.pid() ) && ( it->partner_MAC == from ) )
				{
#if DPS_FOOTER > 0
					//Checksum validation
					if( !(packet.validate_checksum( it, false )) )
					{
						#ifdef DPS_RADIO_DEBUG
						debug().debug( "DPS: checksum error in CONNECTED packet" );
						#endif
						return;
					}
#endif
					if( packet.type() == DPS_Packet_t::DPS_TYPE_HARTBEAT )
					{
						//Server side, check for the counter against replay attack
						if( ( it->client_counter == packet.counter() ) && ( protocol_list_[packet.pid()].server ) )
						{
							it->client_counter++;
							return;
						}
						//Client side, check for the counter against replay attack
						else if( ( it->server_counter == packet.counter() ) && !( protocol_list_[packet.pid()].server ) )
						{
							it->server_counter++;
							return;
						}
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_RPC_ACK )
					{
						for( Buffer_list_iterator act_buffer = buffer_list_.begin(); act_buffer != buffer_list_.end(); ++act_buffer )
						{
							if( (act_buffer->connection_it) == it )
							{
								if( ((packet.fragmentation_flag() == 1) && (act_buffer->processed_size == packet.fragmentation_header_shift())) ||
									(packet.fragmentation_flag() == 0) )
								{
									act_buffer->processed_size += act_buffer->last_fragment_size;
								}
								else
								{
										#ifdef DPS_RADIO_DEBUG
										debug().debug( "DPS: received dupliated ACK");
										#endif
										return;
								}
								
								//Sending completed
								if( act_buffer->processed_size == act_buffer->buffer_length )
								{
									//Free up the buffer
									(protocol_list_[act_buffer->RPC_parameters.Pid].buffer_handler_delegate)( act_buffer->buffer_pointer, act_buffer->buffer_length, false );
									
									//Sending completed, increment the counter
									if( protocol_list_[packet.pid()].server )
										act_buffer->connection_it->server_counter++;
									else
										act_buffer->connection_it->client_counter++;
									
									//remove from the list
									buffer_list_.erase( act_buffer );
								}
								//Send next fragment
								else
								{
									send_RPC( act_buffer );
								}
								
								
								return;
							}
						}
					}
					else if( packet.type() == DPS_Packet_t::DPS_TYPE_RPC_REQUEST )
					{
						//TODO check the counter values
						
						uint16_t actual_payload_length = packet.length - packet.payload_position - DPS_Packet_t::DPS_FOOTER_SIZE;
						
						//Check whether there is a buffer exists for this fragment
						Buffer_list_iterator act_buffer;
						for( act_buffer = buffer_list_.begin(); act_buffer != buffer_list_.end(); ++act_buffer )
						{
							if( (act_buffer->connection_it) == it )
								break;
						}
						
						//There is no buffer for this RPC, create a new one
						if( act_buffer == buffer_list_.end() )
						{
							if( buffer_list_.size() == DPS_MAX_BUFFER_LIST )
							{
								#ifdef DPS_RADIO_DEBUG
								debug().debug( "DPS fatal: buffer list is full!" );
								#endif
								return;
							}
							
							buffer_element_t new_buffer;
							
							//Calculate the full length
							if( packet.fragmentation_flag() == 1 )
								new_buffer.buffer_length = packet.fragmentation_header_length();
							else
								new_buffer.buffer_length = actual_payload_length;
							
							new_buffer.buffer_pointer = (protocol_list_[packet.pid()].buffer_handler_delegate)( NULL, new_buffer.buffer_length, true );
							
							new_buffer.RPC_parameters.Pid = packet.pid();
							new_buffer.RPC_parameters.Fid = packet.fid();
							
							new_buffer.connection_it = it;
							
							new_buffer.outgoing = false;
							
							act_buffer = buffer_list_.insert( new_buffer );
						}
						
						//reset the "timer" for the buffer
						act_buffer->elapsed_time = 0;
						
						//NOTE this does not accept out of order arrival for fragments
						if( act_buffer->processed_size > packet.fragmentation_header_shift() )
						{
							return;
						}
						
						//Copy the content of the actual DPS packet
						if( packet.fragmentation_flag() == 1 )
						{
							memcpy( act_buffer->buffer_pointer + packet.fragmentation_header_shift(), packet.buffer + packet.payload_position, actual_payload_length );
						}
						else
						{
							memcpy( act_buffer->buffer_pointer, packet.buffer + packet.payload_position, actual_payload_length );
						}
						
						//Update the size
						act_buffer->processed_size += actual_payload_length;
						
						//Send back an ACK if it is requested by the sender, use the actual packet since the header has to be almost the same
						if( packet.ack_flag() )
						{
							packet.set_type( DPS_Packet_t::DPS_TYPE_RPC_ACK );
							packet.length = packet.payload_position;
#if DPS_FOOTER > 0
							packet.set_checksum( it, false );
#endif
							radio().send( it->partner_MAC, packet.length, packet.buffer );
						}
						
						//Notify the the RPC_handler if the full RPC is here
						if( act_buffer->processed_size == act_buffer->buffer_length )
						{
							if( protocol_list_[packet.pid()].server )
								it->client_counter++;
							else
								it->server_counter++;
							
							(protocol_list_[packet.pid()].rpc_handler_delegate)( act_buffer->RPC_parameters, act_buffer->buffer_length, act_buffer->buffer_pointer );
							
							buffer_list_.erase( act_buffer );
						}
// 						debug().debug( "RMEM: %i",  mem->mem_free() );
					}
					else
					{
						//TODO process RPC REPLY?
					}
				}
			}
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_DISCOVERY( void* n_in )
	{
		int n = (int)n_in;
		
		Connection_list_iterator it = connection_list_.begin() + n;
		
		send_connection_message( Radio::BROADCAST_ADDRESS, DPS_Packet_t::DPS_TYPE_DISCOVERY, it );
		
		//NOTE may not the expected
		if( it->connection_status == connection_type::SENDING_DISCOVERY )
		{
			it->elapsed_time += DPS_TIMER_DISCOVERY_FREQUENCY;
			timer().template set_timer<self_type, &self_type::send_DISCOVERY>( DPS_TIMER_DISCOVERY_FREQUENCY, this, n_in );
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	request_connection( void* n_in )
	{
		int n = (int)n_in;
		Connection_list_iterator it = connection_list_.begin() + n;
		
		it->connection_status = connection_type::CONNECT_SENT;
		
		//Send a CONNECT to the selected server 
		send_connection_message( it->partner_MAC, DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST, it );
	}
	
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
	typename Radio_P,
	typename Debug_P,
	typename Timer_P,
	typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	general_periodic_timer( void* )
	{
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
		{
			it->elapsed_time += DPS_GENERAL_TIMER_FREQUENCY;
			
			//CONNECTED and ( HARTBEAT_TIMEOUT <= elapsed_time < DELETE_TIMEOUT )
			if(( it->connection_status == connection_type::CONNECTED )
				&& ( it->elapsed_time >= DPS_HARTBEAT_THRESHOLD ) && (it->elapsed_time < DPS_DELETE_CONNECTION_THRESHOLD))
			{
				send_connection_message( it->partner_MAC, DPS_Packet_t::DPS_TYPE_HARTBEAT, it);
				continue;
			}
			
			//For the server
			if( (protocol_list_[it->Pid].server) )
			{
				if( it->elapsed_time >= DPS_DELETE_CONNECTION_THRESHOLD )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug( "DPS: remove client at (%llx) for %i", (long long unsigned)(radio().id()), it->Pid);
					#endif
					
					//TODO check for buffer in use!
					
					connection_list_.erase( it );
					
					//Break the loop if this was the only element
					if( connection_list_.size() == 0 )
						break;
				}
			}
			//For the client
			//The SENDING_DISCOVERY state is handled by another timer&function
			else
			{
				if( it->elapsed_time >= DPS_DELETE_CONNECTION_THRESHOLD )
				{
					#ifdef DPS_RADIO_DEBUG
					debug().debug( "DPS: reDISCOVERY at (%llx) for %i", (long long unsigned)(radio().id()), it->Pid);
					#endif
					
					//TODO check for buffer in use!
					
					it->connection_status = connection_type::SENDING_DISCOVERY;
					it->client_counter = rand()() % (0xFFFFFFFF);
					it->link_metric = 0xFFFF;
// 					it->server_counter = 0;
// 					it->partner_MAC = Radio::NULL_NODE_ID;
// 					it->connection_nonce = 0;
					
					timer().template set_timer<self_type, &self_type::send_DISCOVERY>( DPS_TIMER_DISCOVERY_FREQUENCY, this, (void*)(it-connection_list_.begin()) );
				}
			}
			
		}
		
		for( Buffer_list_iterator it = buffer_list_.begin(); it != buffer_list_.end(); ++it )
		{
			it->elapsed_time += DPS_GENERAL_TIMER_FREQUENCY;
			
			if( it->outgoing && ( it->elapsed_time > DPS_ACK_TIMEOUT ) )
			{
				send_RPC( it );
			}
			else if( !(it->outgoing) && ( it->elapsed_time > DPS_FRAGMENT_COLLECTION_TIMEOUT ) )
			{
				//Free up the buffer
				(protocol_list_[it->RPC_parameters.Pid].buffer_handler_delegate)( it->buffer_pointer, it->buffer_length, false );
				
				//Sending uncompleted, increment the counter
				if( protocol_list_[it->connection_it->Pid].server )
					it->connection_it->server_counter++;
				else
					it->connection_it->client_counter++;
				
				//remove from the list
				buffer_list_.erase( it );
				
				//Break the loop if this was the only element
				if( buffer_list_.size() == 0 )
					break;
			}
		}
		
		
		timer().template set_timer<self_type, &self_type::general_periodic_timer>( DPS_GENERAL_TIMER_FREQUENCY, this, NULL );
	}
	
}
#endif
