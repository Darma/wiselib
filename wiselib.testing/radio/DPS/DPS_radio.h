/***************************************************************************
 ** This file is part of the generic algorithm library Wiselib.           **
 ** Copyright (C) 2008,2009 by the Wisebed (www.wisebed.eu) project.      **
 **                                                                       **
 ** The Wiselib is free software: you can redistribute it and/or modify   **
 ** it under the terms of the GNU Lesser General Public License as        **
 ** published by the Free Software Foundation, either version 3 of the    **
 ** License, or (at your option) any later version.                       **
 **                                                                       **
 ** The Wiselib is distributed in the hope that it will be useful,        **
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of        **
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
 ** GNU Lesser General Public License for more details.                   **
 **                                                                       **
 ** You should have received a copy of the GNU Lesser General Public      **
 ** License along with the Wiselib.                                       **
 ** If not, see <http://www.gnu.org/licenses/>.                           **
 ***************************************************************************/

/*
* File: DPS_radio.h
* Class(es): 
* Author: Daniel Gehberger - GSoC 2013 - DPS project
*/

#ifndef __RADIO_DPS_RADIO_H__
#define __RADIO_DPS_RADIO_H__

#include "config_testing.h"

#include "util/delegates/delegate.hpp"
#include "util/pstl/vector_static.h"
#include "util/pstl/map_static_vector.h"
#include "util/pstl/pair.h"

#include "radio/DPS/DPS_packet.h"


namespace wiselib
{
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Connection_t
	{
		typedef Radio_P Radio;
		typedef typename Radio::node_id_t radio_node_id_t;
		
	public:
		Connection_t()
		: partner_MAC( Radio::NULL_NODE_ID ),
		client_counter(0),
		server_counter(0),
		connection_nonce(0),
		last_sent_timer( 0 ),
		last_received_timer( 0 ),
		link_metric(0xFFFF),
		Pid(0),
		connection_status(UNUSED)
		{}
		
		enum connection_status
		{
			//Client
			UNUSED = 0,
			SENDING_DISCOVERY = 1,
			CONNECT_SENT = 2,
			
			//Server
			ADVERTISE_SENT = 4,
			ALLOW_SENT = 5,
			
			CONNECTED = 6
		};
		
		/**
		 * MAC address of the communication partner (server/client)
		 */
		radio_node_id_t partner_MAC;
		
		/**
		 * CNT the Client
		 */
		uint32_t client_counter;
		
		/**
		 * CNT of the server
		 */
		uint32_t server_counter;
		
		/**
		 * Nonce for the connection, generated by the client in the CONNECT message
		 */
		uint32_t connection_nonce;
				
		/**
		 */
		uint16_t last_sent_timer;
		
		/**
		 */
		uint16_t last_received_timer;
		
		/**
		 * The link metric for the actual connection, only used at connection setup at the moment
		 */
		uint16_t link_metric;
		
		/**
		 * Connection keys (nonce XOR negotiated key)
		 */
		uint8_t key[16];
// 		uint8_t my_connection_key[16];
// 		uint8_t partner_connection_key[16];
		
		/**
		 * Protocol ID pair
		 */
		uint8_t Pid;
		
		/**
		 * Status of the DPS connection
		 */
		uint8_t connection_status;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class DPS_node_id_type
	{
		public:
		typedef Radio_P Radio;
		typedef typename Radio::node_id_t node_id_t;
		
		DPS_node_id_type()
		: target_address( 0 ),
		Pid( 0 ),
		Fid( 0 ),
		ack_required( 0 )
		{}
		
		node_id_t target_address;
		uint8_t Pid;
		uint8_t Fid;
		uint8_t ack_required;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P>
	class Protocol_t
	{
		typedef Radio_P Radio;
		typedef DPS_node_id_type<Radio> node_id_t;
		typedef typename Radio::block_data_t block_data_t;
		
	public:
		Protocol_t()
		: server( false ),
		rpc_handler_delegate(RPC_handler_delegate_t()),
		buffer_handler_delegate(buffer_handler_delegate_t())
		{}
		
		/**
		 * Server / Client flag
		 */
		bool server;
		
		/**
		 * RPC_handler delegate
		 * Source, Fid, length, buffer
		 */
		typedef delegate3<int, node_id_t, uint16_t, block_data_t*> RPC_handler_delegate_t;
		RPC_handler_delegate_t rpc_handler_delegate;
		
		/**
		 * buffer handler delegate
		 * function for 2 use cases
		 * 	- get a buffer for incoming messages
		 * 	- when ACK is required then free up the buffer
		 */
		typedef delegate3<block_data_t*, block_data_t*, uint16_t, bool> buffer_handler_delegate_t;
		buffer_handler_delegate_t buffer_handler_delegate;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
	
	
	/**
	* \brief 
	*/
	template<typename Radio_P,
		typename Connection_list_iterator_P>
	class buffer_list_type
	{
		typedef Radio_P Radio;
		typedef DPS_node_id_type<Radio> node_id_t;
		typedef Connection_list_iterator_P Connection_list_iterator;
		typedef typename Radio::block_data_t block_data_t;
		
	public:
		buffer_list_type()
		: buffer_pointer( NULL ),
		connection_it( NULL ),
		RPC_parameters(),
		processed_size( 0 ),
		last_fragment_size( 0 ),
		elapsed_time( 0 ),
		buffer_length( 0 ),
		transmission_retries( 0 ),
		outgoing( true )
		{}
		
		/**
		 */
		block_data_t* buffer_pointer;
		
		/**
		 */
		Connection_list_iterator connection_it;
		
		/**
		 */
		node_id_t RPC_parameters;
		
		/**
		 */
		uint16_t processed_size;
		
		/**
		 */
		uint16_t last_fragment_size;
		
		/**
		 */
		uint16_t elapsed_time;
		
		/**
		 */
		uint16_t buffer_length;
		
		/**
		 */
		uint16_t transmission_retries;
		
		/**
		 */
		bool outgoing;
	};
	
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
		
		
	/**
	* \brief DPS radio
	*/
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	class DPS_Radio
	{
	public:
		typedef OsModel_P OsModel;
		typedef Radio_P Radio;
		typedef Debug_P Debug;
		typedef Timer_P Timer;
		typedef Rand_P Rand;
		
		typedef DPS_Radio<OsModel, Radio, Debug, Timer, Rand> self_type;
		typedef self_type* self_pointer_t;
		
		typedef typename Radio::node_id_t radio_node_id_t;
		typedef typename Radio::size_t size_t;
		typedef typename Radio::block_data_t block_data_t;
		typedef typename Radio::message_id_t message_id_t;
		typedef typename Radio::ExtendedData ExtendedData;
		
		//node_id_t as a triplet: P_id, F_id, ack_flag
		typedef DPS_node_id_type<Radio> node_id_t;
		
		typedef Protocol_t<Radio> protocol_type;
		typedef wiselib::pair<uint8_t, protocol_type> newprotocol_t;
		typedef MapStaticVector<OsModel, uint8_t, protocol_type, DPS_MAX_PROTOCOLS> Protocol_list_t;
		
		typedef Connection_t<Radio> connection_type;
		typedef vector_static<OsModel, connection_type, DPS_MAX_CONNECTIONS> Connection_list_t;
		typedef typename Connection_list_t::iterator Connection_list_iterator;
		
		typedef buffer_list_type<Radio, Connection_list_iterator> buffer_element_t;
		typedef vector_static<OsModel, buffer_element_t, DPS_MAX_BUFFER_LIST> Buffer_list_t;
		typedef typename Buffer_list_t::iterator Buffer_list_iterator;
		
		typedef DPS_Packet<OsModel, self_type, Debug, Connection_list_iterator> DPS_Packet_t;
		
		enum callback_values
		{
			NEW_CONNECTION = 254,
			DELETE_CONNECTION = 255
		};

		// --------------------------------------------------------------------
		enum ErrorCodes
		{
			SUCCESS = OsModel::SUCCESS,
			ERR_UNSPEC = OsModel::ERR_UNSPEC,
			ERR_NOTIMPL = OsModel::ERR_NOTIMPL,
			ERR_HOSTUNREACH = OsModel::ERR_HOSTUNREACH,
			NO_CONNECTION = 101
		};
		// --------------------------------------------------------------------
		
		enum SpecialNodeIds {
		BROADCAST_ADDRESS = Radio_P::BROADCAST_ADDRESS, ///< All nodes in communication range
		NULL_NODE_ID      = Radio_P::NULL_NODE_ID      ///< Unknown/No node id
		};
		
		// --------------------------------------------------------------------
		enum Restrictions {
			MAX_MESSAGE_LENGTH = Radio::MAX_MESSAGE_LENGTH  ///< Maximal number of bytes in payload
		};
		
		// --------------------------------------------------------------------
		///@name Construction / Destruction
		///@{
		DPS_Radio();
		~DPS_Radio();
		///@}
		
		int init( Radio& radio, Debug& debug, Timer& timer, Rand& rand )
		{
			radio_ = &radio;
			debug_ = &debug;
			timer_ = &timer;
			rand_ = &rand;
			
			//TODO
			rand_->srand( id() );
			
			return SUCCESS;
		}
		
		inline int init();
		inline int destruct();
		
		///@name Routing Control
		///@{
		int enable_radio( void );
		int disable_radio( void );
		///@}
		
		///@name Radio Concept
		///@{
		/**
		*/
		int send( node_id_t receiver, uint16_t length, block_data_t *data );
		
		/**
		 * \brief
		*/
		void receive( radio_node_id_t from, size_t length, block_data_t *data,  ExtendedData const &ex );
		
		/**
		 * \brief
		*/
		radio_node_id_t id()
		{
			return radio().id();
		}
		///@}
		
		
		
		/**
		 * \brief
		 */
		template<class T, int (T::*TMethod)(node_id_t, uint16_t, block_data_t*), block_data_t* (T::*TMethod2)(block_data_t*, uint16_t, bool)>
		int reg_recv_callback( T *obj_pnt, uint8_t Pid, bool server )
		{
#ifdef DPS_COLLECT_STATS
			reset_connection = 0;
			stat_time = 0;
			buffer_timeouts = 0;
			ACK_timeouts = 0;
#endif
			
			
			//The Pid has been already registered
			if( protocol_list_.find( Pid ) != protocol_list_.end() )
				return ERR_UNSPEC;
			
			//Save the registration: function pointer and server flag
			newprotocol_t newprotocol;
			newprotocol.first = Pid;
			newprotocol.second.rpc_handler_delegate = protocol_type::RPC_handler_delegate_t::template from_method<T, TMethod>( obj_pnt );
			newprotocol.second.buffer_handler_delegate = protocol_type::buffer_handler_delegate_t::template from_method<T, TMethod2>( obj_pnt );
			newprotocol.second.server = server;
			
			protocol_list_.push_back(newprotocol);
			
			#if DPS_RADIO_DEBUG >= 1
			debug().debug( "DPS: Reg %i C/S: %lx", Pid, server);
			#endif
			
			//Start the DISCOVERY if it is a client
			if( !server )
			{
				connection_type connection;
				connection.Pid = Pid;
				connection.connection_status = connection_type::SENDING_DISCOVERY;
				connection.client_counter = rand()() % (0xFFFFFFFF);
				
				Connection_list_iterator it = connection_list_.insert( connection );
				
				if( it == connection_list_.end() )
				{
					#if DPS_RADIO_DEBUG >= 0
					debug().debug("DPS: ConnLFull");
					#endif
					return ERR_UNSPEC;
				}
				
				int tmp = DPS_Packet_t::DPS_TYPE_DISCOVERY << 8;
				tmp |= (it-connection_list_.begin());
				timer().template set_timer<self_type, &self_type::send_delayed_connection_message>( DPS_TIMER_DISCOVERY_FREQUENCY, this, (void*)(tmp) );
			}
			
			return SUCCESS;
		}
		
		/**
		 * \brief
		 */
		int unreg_recv_callback( uint8_t Pid )
		{
			return ERR_NOTIMPL;
		}
		
				
		////////////// STAT
#ifdef DPS_COLLECT_STATS
		int reset_connection;
		int buffer_timeouts;
		int ACK_timeouts;
		int stat_time;
#endif
		
	private:
		
		/**
		* \brief
		*/
		void send_RPC( Buffer_list_iterator act_buffer );
		
		/**
		* \brief
		*/
		int send_connection_message( radio_node_id_t destination, uint8_t type, Connection_list_iterator connection );
		
		/**
		* \brief Function called by the timer in order to send DISCOVERY/CONNECT message
		* n_in --> type|iterator_shift
		*/
		void send_delayed_connection_message( void* n_in );
		
		/**
		* \brief Function called by the timer in order to mentain timing in DPS
		*/
		void general_periodic_timer( void* );
		
		/**
		 * \brief Calculate the connection key
		 * NOTE: The nonce must be set for the connection when this function is called.
		 */
		void generate_connection_key( Connection_list_iterator connection );
		
		//NOTE: only for TEST
		void turn_off( void* )
		{
			//disable_radio(); is not working for shawn...
			disabled_ = true;
		}
		
		bool disabled_;
		
		/**
		 * Map for the registered protocols
		 */
		Protocol_list_t protocol_list_;
		
		/**
		 * List for the connections
		 */
		Connection_list_t connection_list_;
		
		/**
		 * List for the in/outgoing contents
		 */
		Buffer_list_t buffer_list_;
		
		//Stored callback_id for radio
		uint8_t callback_id_;
		
		Radio& radio()
		{ return *radio_; }
		
		Debug& debug()
		{ return *debug_; }
		
		Timer& timer()
		{ return *timer_; }
		
		Rand& rand()
		{ return *rand_; }
		
		typename Radio::self_pointer_t radio_;
		typename Debug::self_pointer_t debug_;
		typename Timer::self_pointer_t timer_;
		typename Rand::self_pointer_t rand_;
		
	};
	
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	// -----------------------------------------------------------------------
	
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	DPS_Radio()
	: radio_ ( 0 ),
	debug_ ( 0 )
	{}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	~DPS_Radio()
	{
		disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	init( void )
	{
		if ( enable_radio() != SUCCESS )
			return ERR_UNSPEC;
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	destruct( void )
	{
		return disable_radio();
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	enable_radio( void )
	{
		#if DPS_RADIO_DEBUG >= 2
		debug().debug( "DPS init" );
		#endif
		
		radio().enable_radio();
		
		radio().template reg_recv_callback<self_type, &self_type::receive>( this );
		
		//Start the periodic timer with an extra 0.5 sec delay and a random time shift
		int tmp = rand()() & 0x7FF + 500;
		timer().template set_timer<self_type, &self_type::general_periodic_timer>( DPS_GENERAL_TIMER_FREQUENCY + tmp, this, NULL );
		
		
		//NOTE only for TEST
		disabled_ = false;
		if( id() == 0 )
			timer().template set_timer<self_type, &self_type::turn_off>( 8000, this, NULL );
		
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	disable_radio( void )
	{
// 		#if DPS_RADIO_DEBUG >= 1
// 		debug().debug( "DPS Radio: Disable" );
// 		#endif
		
		if( radio().disable_radio() != SUCCESS )
			return ERR_UNSPEC;
		radio().template unreg_recv_callback(callback_id_);
		
		return SUCCESS;
	}
	
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	generate_connection_key( Connection_list_iterator connection )
	{
		//Key derivation
		memcpy(connection->key, DPS_REQUEST_KEY, 16);
		radio_node_id_t x, y;
		
		//Use a fixed order of the two addresses
		if( connection->partner_MAC > id() )
		{
			x = connection->partner_MAC;
			y = id();
		}
		else
		{
			x = id();
			y = connection->partner_MAC;
		}
		memcpy(&(connection->key[0]), &x, sizeof(radio_node_id_t));
		memcpy(&(connection->key[8]), &y, sizeof(radio_node_id_t));
		
		// XOR it with the connection_nonce
		for (uint8_t i=0; i<=12; i=i+4) {
			connection->key[i+0] ^= ((connection->connection_nonce >> 24) & 0xFF);
			connection->key[i+1] ^= ((connection->connection_nonce >> 16) & 0xFF);
			connection->key[i+2] ^= ((connection->connection_nonce >> 8) & 0xFF);
			connection->key[i+3] ^= ((connection->connection_nonce >> 0) & 0xFF);
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_connection_message( radio_node_id_t destination, uint8_t type, Connection_list_iterator connection )
	{
		
		//NOTE only for TEST
		if( disabled_ )
			return ERR_UNSPEC;
		
		//Create a packet, no fragmentation
		DPS_Packet_t packet( type, false );
		block_data_t* payload_act_pointer=packet.get_payload();
		
		//Set the common fields
		packet.set_pid( connection->Pid );
		packet.set_counter( connection->client_counter );
		
		bool use_requst_key_for_checksum = false;
		
		if( type == DPS_Packet_t::DPS_TYPE_HEARTBEAT )
		{
			if( protocol_list_[connection->Pid].server )
			{
				packet.set_counter( connection->server_counter );
				connection->server_counter++;
			}
			else
			{
				connection->client_counter++;
			}
		}
		//TODO #ifdef DPS_COMPILE_ONLY_CLIENT_CODES ?
		else if( type == DPS_Packet_t::DPS_TYPE_DISCOVERY || type == DPS_Packet_t::DPS_TYPE_ADVERTISE )
		{
			use_requst_key_for_checksum = true;
			
			//TODO handle filters
// 			uint8_t number_of_filters = 0;
			payload_act_pointer[0] = 0; //number_of_filters;
			
			payload_act_pointer++;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //CLIENT CODE
		{
			connection->connection_nonce = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->connection_nonce, 0, 32 );
			payload_act_pointer += 4;
			
			//Generate the key for the connection based on the nonce
			generate_connection_key( connection );
		}
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ) //SERVER CODE
		{
			connection->server_counter = rand()() % (0xFFFFFFFF);
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->server_counter, 0, 32 );
			payload_act_pointer += 4;
		}
#endif
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ) //CLIENT CODE
		{
			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, connection->server_counter, 0, 32 );
			payload_act_pointer += 4;
		}
		else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ABORT )
		{
// 			uint32_t dummy = rand()() % (0xFFFFFFFF);
// 			bitwise_write<OsModel, block_data_t, uint32_t>( payload_act_pointer, dummy, 0, 32 );
			payload_act_pointer += 4;
		}
		else
		{
			#if DPS_RADIO_DEBUG >= 0
			debug().debug( "DPS: UnknownTypeCode");
			#endif
			return ERR_UNSPEC;
		}
		
		//Calculate the full length
		packet.length += payload_act_pointer - packet.get_payload();
		
#if DPS_FOOTER > 0
// 		packet.set_debug( *debug_ );
		packet.set_checksum( connection, use_requst_key_for_checksum );
#endif
		
		
		#if DPS_RADIO_DEBUG >= 2
		if( type != DPS_Packet_t::DPS_TYPE_HEARTBEAT )
		debug().debug( "DPS: send to %lx, T: %i", (destination), type);
// 		debug().debug( "DPS: send from %lx to %lx, packet type: %i", (radio().id()), (destination), type);
		#endif
		
// 		packet.set_debug( *debug_ );
// 		packet.print_header();
		
		connection->last_sent_timer = 0;

		radio().send( destination, packet.length, packet.buffer );
		
		return SUCCESS;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	int
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send( node_id_t destination, uint16_t length, block_data_t *data )
	{
		//NOTE only for TEST
		if( disabled_ )
			return ERR_UNSPEC;
		
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
		{
			if( it->Pid == destination.Pid && it->connection_status == connection_type::CONNECTED )
			{
				//If the destination is specified, then it should match as well
				//Usecase: server --> client
				if( NULL_NODE_ID == destination.target_address || 
					it->partner_MAC == destination.target_address )
				{
					if( buffer_list_.size() == DPS_MAX_BUFFER_LIST )
					{
						#if DPS_RADIO_DEBUG >= 0
						debug().debug( "DPS BuffLFull" );
						#endif
						return ERR_UNSPEC;
					}
					
					buffer_element_t new_buffer;
					new_buffer.buffer_length = length;
					new_buffer.buffer_pointer = data;
					new_buffer.RPC_parameters = destination;
					new_buffer.connection_it = it;
					new_buffer.outgoing = true;
					
					Buffer_list_iterator act_buffer = buffer_list_.insert( new_buffer );
					
					send_RPC( act_buffer );
					
					return SUCCESS;
				}
			}
		}
		debug().debug( "DPS Cannot send, no conn!" );
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
			debug().debug("-- %lx %i", it->partner_MAC, it->connection_status );
		return NO_CONNECTION;
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
	typename Radio_P,
	typename Debug_P,
	typename Timer_P,
	typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_RPC( Buffer_list_iterator act_buffer )
	{
		act_buffer->connection_it->last_sent_timer = 0;
		
		bool fragmentation = false;
		
		//Check the size of the data: Max message size vs. header + payload + footer
		if( Radio::MAX_MESSAGE_LENGTH < act_buffer->buffer_length + DPS_Packet_t::DPS_RPC_HEADER_SIZE + DPS_Packet_t::DPS_FOOTER_SIZE )
			fragmentation = true;
		
		//Create a packet with or without fragmentation
		DPS_Packet_t packet( DPS_Packet_t::DPS_TYPE_RPC_REQUEST, fragmentation );
		
		packet.set_pid( act_buffer->RPC_parameters.Pid );
		packet.set_fid( act_buffer->RPC_parameters.Fid );
		packet.set_ack_flag( act_buffer->RPC_parameters.ack_required );
		
		//Save the counter
		uint32_t* counter;
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
		if( protocol_list_[packet.pid()].server )
		{
			counter = &(act_buffer->connection_it->server_counter);
			packet.set_counter( act_buffer->connection_it->server_counter );
		}
		else
#endif
		{
			counter = &(act_buffer->connection_it->client_counter);
			packet.set_counter( act_buffer->connection_it->client_counter );
		}
		
		//execute the loop at least once
		bool more_to_send = true;
		do{
		
			//Fill in the fragmentation header
			if( fragmentation )
			{
				//Full size of the RPC and the shift for this fragment
				packet.set_fragmentation_header( act_buffer->buffer_length, act_buffer->processed_size );
			}
			
			
			//This is the max length for the payload: MAX - Header - Footer
			uint8_t act_payload_size = Radio::MAX_MESSAGE_LENGTH - packet.payload_position - DPS_Packet_t::DPS_FOOTER_SIZE;
			//Calculate the payload size for this DPS packet
			//If the remaining size (buffer_length-processed_size) is bigger than the max payload size
			if( act_payload_size > act_buffer->buffer_length - act_buffer->processed_size)
				//only the required size
				act_payload_size = act_buffer->buffer_length - act_buffer->processed_size;
			
			//Copy the payload into the packet
			memcpy( packet.buffer + packet.length, act_buffer->buffer_pointer + act_buffer->processed_size, act_payload_size);
			packet.length += act_payload_size;
			
	#if DPS_FOOTER > 0
			packet.set_checksum( act_buffer->connection_it, false );
	#endif
			
			#if DPS_RADIO_DEBUG >= 2
			if( fragmentation )
				debug().debug( "DPS: send RPC frag (%i/%i) to %lx (%i/%i)", packet.fragmentation_header_length(), packet.fragmentation_header_shift(), (act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
// 				debug().debug( "DPS: send RPC frag (%i/%i) from %lx to %lx (%i/%i)", packet.fragmentation_header_length(), packet.fragmentation_header_shift(), (radio().id()), (act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
			else
				debug().debug( "DPS: send RPC to %lx (%i/%i)", (act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
// 				debug().debug( "DPS: send RPC from %lx to %lx (%i/%i)", (radio().id()), (act_buffer->connection_it->partner_MAC), act_buffer->RPC_parameters.Pid, act_buffer->RPC_parameters.Fid);
			#endif
			
			//Send the (fragment)
			radio().send( act_buffer->connection_it->partner_MAC, packet.length, packet.buffer );
			
			//Wait for the ACK, this function will be called again by the timeout/receive(ACK) if there are more fragments
			if( act_buffer->RPC_parameters.ack_required )
			{
				act_buffer->last_fragment_size = act_payload_size;
				more_to_send = false;
			}
			//Packet completed and no ACK
			else if( act_buffer->processed_size + act_payload_size == act_buffer->buffer_length )
			{
				//Free up the buffer
				(protocol_list_[act_buffer->RPC_parameters.Pid].buffer_handler_delegate)( act_buffer->buffer_pointer, act_buffer->buffer_length, false );
				
				more_to_send = false;
				
				//Sending completed, increment the counter
				(*counter)++;
				
				//remove from the list
				buffer_list_.erase( act_buffer );
			}
			//more fragments and no ack, reset the DPS packet length (RPC header + Frag header)
			else 
			{
				//Increase the processed size
				act_buffer->processed_size += act_payload_size;
				//reset the DPS packet
				packet.length = DPS_Packet_t::DPS_RPC_HEADER_SIZE + DPS_Packet_t::DPS_FRAGMENTATION_HEADER_SIZE;
			}
		}while( more_to_send );
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	receive( radio_node_id_t from, size_t length, block_data_t *data, ExtendedData const &ex ) 
	{
		//Re seed the random generator
		uint32_t seed = rand()() % (0xFFFFFFFF);
		seed ^= (( (uint16_t)from ^ ex.link_metric() )) << 16 | (( (uint16_t)id() ^ ex.link_metric() ));
		rand_->srand( seed );
		
		//Drop non-wisebed messages
		if( from > 0x2500 )
			return;
		
		//The initial 2 bits must be: 10
		if( bitwise_read<OsModel, block_data_t, uint32_t>( data, 0, 2 ) != 2 )
			return;
		
		DPS_Packet_t packet( length, data );
		block_data_t* payload=packet.get_payload();
		
		//used many times
		uint8_t type = packet.type();
		
// // 		packet.set_debug( *debug_ );
// 		packet.print_header();
		
		#if DPS_RADIO_DEBUG >= 2
		if( type != DPS_Packet_t::DPS_TYPE_HEARTBEAT )
		{
			debug().debug( "DPS: Rec from %lx, T: %i len %i Ctr %x", (from), type, length, packet.counter());
// 			debug().debug("packet: %x %x %x %x %x %x %x %x %x", data[0], data[1],data[2],data[3],data[4],data[5],data[6],data[7],data[8] );
		}
		#endif
		
		//Handled in a different way since there is no connection in the list for this
#ifdef DPS_COMPILE_ONLY_CLIENT_CODES
		if( type == DPS_Packet_t::DPS_TYPE_DISCOVERY ) //CLIENT CODE
			return;
#else
		if( type == DPS_Packet_t::DPS_TYPE_DISCOVERY ) //SERVER CODE
		{
	#if DPS_FOOTER > 0
			//Checksum validation based on the REQUEST key
// 			packet.set_debug( *debug_ );
			if( !(packet.validate_checksum( connection_list_.end(), true )) )
			{
				#if DPS_RADIO_DEBUG >= 0
				debug().debug( "DPS D CHKErr" );
				#endif
				return;
			}
	#endif
	
// 			debug().debug("DPS DISC REC %i", packet.pid());
			//Receive a Discovery at a node which provides the protocol as a server
			if( protocol_list_.find(packet.pid()) != protocol_list_.end() && protocol_list_[packet.pid()].server )
			{
				//TODO handle filters
// 				debug().debug("DPS DISC REC IN");
				
				Connection_list_iterator conn_it = connection_list_.begin();
				//Check whether there has been a connection already established with this client
				for( ; conn_it != connection_list_.end(); ++conn_it )
				{
					if( conn_it->Pid == packet.pid() && conn_it->partner_MAC == from )
					{
						//This a repeated DISCOVERY, so repeat the ADVERTISE but do not add a new connection
						if( conn_it->connection_status == connection_type::ADVERTISE_SENT )
						{
							break;
						}
						else
							return;
					}
				}
				
				//If this is a new DISCOVERY --> add a new connection
				if( conn_it == connection_list_.end() )
				{
					if( connection_list_.size() == DPS_MAX_CONNECTIONS )
					{
						#if DPS_RADIO_DEBUG >= 0
						debug().debug("DPS ConnLFull");
						for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
							debug().debug("-- %lx %i", it->partner_MAC, it->connection_status );
						#endif
						return;
					}
					
					//Create the new connection entry and add to the list
					connection_type connection;
					connection.Pid = packet.pid();
					connection.connection_status = connection_type::ADVERTISE_SENT;
					connection.client_counter = packet.counter();
					connection.partner_MAC = from;
					
					conn_it = connection_list_.insert( connection );
				}
				
				//Reset the connection timer
				conn_it->last_received_timer = 0;
				
				send_connection_message( from, DPS_Packet_t::DPS_TYPE_ADVERTISE, conn_it );
			}
			return;
		}
#endif
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
		{
			if( it->Pid == packet.pid() )
			{
				//Ignore connections with other nodes if the partner is known
				if( type != DPS_Packet_t::DPS_TYPE_ADVERTISE && it->partner_MAC != from )
					continue;
				
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
				//This is an expensive request...
				bool server = protocol_list_[packet.pid()].server;
				
				//Quick hack for the checksum interoperability
				if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST )
					it->client_counter = packet.counter();
#endif
				
				//validate counters and save the pointer of the actual one
				//The counter value in the packet must be greater or equal compared to the expected,
				uint32_t* counter = NULL;
				
				
				bool packet_counter_acceptable_as_SERVER_counter = false;
				bool packet_counter_acceptable_as_CLIENT_counter = false;
				
				uint32 packet_counter = packet.counter();
#ifdef DPS_ENABLE_RPC_HEADER_COMPRESSION
				if( packet.compressed_headers )
				{
					//Here we only have the last 8 bits from the counter, so we have to accept counter values "less" than
					//the expected, now these are accepted if the difference is at least 250 to tolerate some packet loss.
					packet_counter = packet_counter & 0x000000FF;
					uint8_t LSB_server_counter = it->server_counter & 0x000000FF;
					uint8_t LSB_client_counter = it->client_counter & 0x000000FF;
					packet_counter_acceptable_as_SERVER_counter = ( LSB_server_counter <= packet_counter ) || ( LSB_server_counter-packet_counter > 250 );
					packet_counter_acceptable_as_CLIENT_counter = ( LSB_client_counter <= packet_counter ) || ( LSB_client_counter-packet_counter > 250 );
				}
				else
#endif
				{
					packet_counter_acceptable_as_SERVER_counter = it->server_counter <= packet_counter;
					packet_counter_acceptable_as_CLIENT_counter = it->client_counter <= packet_counter;
				}
				
				
				
				//For connection messages we always use the client counter
				if (type <= DPS_Packet_t::DPS_TYPE_DISCONNECT_FINISH )
				{
					if( packet_counter_acceptable_as_CLIENT_counter )
						counter = &(it->client_counter);
				}
				//For ACK-s the own counter value is used (server - server) (client -client)
				else if( type == DPS_Packet_t::DPS_TYPE_RPC_ACK )
				{
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
					if( server )
						if( packet_counter_acceptable_as_SERVER_counter )
							counter = &(it->server_counter);
					else 
#endif
						if ( packet_counter_acceptable_as_CLIENT_counter )
							counter = &(it->client_counter);
				}
				//For normal RPC messages, the other partie's counter is used
				else
				{
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
					if( server )
					{
						if ( packet_counter_acceptable_as_CLIENT_counter )
							counter = &(it->client_counter);
					}
					else 
#endif
					{
						if( packet_counter_acceptable_as_SERVER_counter )
							counter = &(it->server_counter);
					}
				}

// 				//Incorrect counter value if the pointer is still NULL
				if( counter == NULL )
				{
					#if DPS_RADIO_DEBUG >= 0
// 					debug().debug( "DPS CNTErr " );
					debug().debug( "DPS CNTErr from: %lx type: %i", (from), type);
					debug().debug( "Server: %x",(it->server_counter));
					debug().debug( "Client: %x",(it->client_counter));
					debug().debug( "Packet: %x",(packet.counter()) );
					#endif
					return;
				}
// 				debug().debug( "DPS: packet S: %lx C: %lx P: %lx", (it->server_counter), (it->client_counter), (packet.counter()) );
				
				//Reset the connection timer
				it->last_received_timer = 0;
				
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
				//CONNECTION_REQUEST must be pre-processed to calculate the connection key
				if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //SERVER SIDE
				{
					//TODO check for available resources?
					
					it->connection_nonce = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
					
					//Generate the key for the connection based on the nonce
					generate_connection_key( it );
				}
#endif
				
				#if DPS_FOOTER > 0
				//Checksum validation, use the request key for ADVERTISE packets and the connection key for the rest
				if( !(packet.validate_checksum( it, type == DPS_Packet_t::DPS_TYPE_ADVERTISE )) )
				{
					#if DPS_RADIO_DEBUG >= 0
					debug().debug( "DPS CHKErr" );
					#endif
					
					//If there is a problem in a connection message, drop the connection
					if ( type <= DPS_Packet_t::DPS_TYPE_DISCONNECT_FINISH )
						connection_list_.erase( it );
					return;
				}
				#endif
				
			//-----------Connected messages----------
				bool fragmented = ( packet.fragmentation_flag() == 1 );
				
				//The heartbeat is the most common message type
				if( type == DPS_Packet_t::DPS_TYPE_HEARTBEAT )
				{
					//increment the counter, these are never compressed
					(*counter) = packet_counter;
				}
				else if( type == DPS_Packet_t::DPS_TYPE_RPC_ACK )
				{
					
					for( Buffer_list_iterator act_buffer = buffer_list_.begin(); act_buffer != buffer_list_.end(); ++act_buffer )
					{
						if( (act_buffer->connection_it) == it )
						{
							if( ((fragmented) && (act_buffer->processed_size == packet.fragmentation_header_shift())) ||
								(!fragmented) )
							{
								act_buffer->processed_size += act_buffer->last_fragment_size;
							}
							else
							{
									#if DPS_RADIO_DEBUG >= 1
									debug().debug( "DPS DuplAck %i", act_buffer->processed_size);
									#endif
									return;
							}
							
							//Sending completed
							if( act_buffer->processed_size == act_buffer->buffer_length )
							{
								//Free up the buffer
								(protocol_list_[act_buffer->RPC_parameters.Pid].buffer_handler_delegate)( act_buffer->buffer_pointer, act_buffer->buffer_length, false );
								
								//Sending completed, increment the counter
								(*counter)++;
								
								//remove from the list
								buffer_list_.erase( act_buffer );
							}
							//Send next fragment
							else
							{
								act_buffer->transmission_retries = 0;
								send_RPC( act_buffer );
							}
							return;
						}
					}
				}
				else if( type == DPS_Packet_t::DPS_TYPE_RPC_REQUEST )
				{
					//Payload = length - header [-footer]
					uint16_t actual_payload_length = packet.length - packet.payload_position - DPS_Packet_t::DPS_FOOTER_SIZE;
					
					//Check whether there is a buffer for this fragment
					Buffer_list_iterator act_buffer;
					for( act_buffer = buffer_list_.begin(); act_buffer != buffer_list_.end(); ++act_buffer )
					{
						if( (act_buffer->connection_it) == it )
							break;
					}
					
					//There is no buffer for this RPC, create a new one
					if( act_buffer == buffer_list_.end() )
					{
						if( buffer_list_.size() == DPS_MAX_BUFFER_LIST )
						{
							#if DPS_RADIO_DEBUG >= 0
							debug().debug( "DPS BuffLFull" );
							#endif
							return;
						}
						
						
						buffer_element_t new_buffer;
						
						//Calculate the full length
						if( fragmented )
							new_buffer.buffer_length = packet.fragmentation_header_length();
						else
							new_buffer.buffer_length = actual_payload_length;
						
						//Get a new buffer from the stub/skeleton
						new_buffer.buffer_pointer = (protocol_list_[packet.pid()].buffer_handler_delegate)( NULL, new_buffer.buffer_length, true );
						
						if( new_buffer.buffer_pointer == NULL )
						{
							debug().debug("DPS NO BUF");
							return;
						}
						new_buffer.RPC_parameters.Pid = packet.pid();
						new_buffer.RPC_parameters.Fid = packet.fid();
						new_buffer.connection_it = it;
						new_buffer.outgoing = false;
						
						act_buffer = buffer_list_.insert( new_buffer );
					}
					else
					{
						//reset the "timer" for the buffer
						act_buffer->elapsed_time = 0;
					}
					
					//Copy the content of the actual DPS packet
					//The extra validation is to avoid the copy of a duplicated fragment. These cannot be dropped (return) before
					//this since the reason can be the lost ACK and it must be repeated but that mechanism uses the same packet.
					bool DF_drop = false; //reduce the number of if-s
					if( fragmented )
					{
						if( act_buffer->processed_size == packet.fragmentation_header_shift() )
							memcpy( act_buffer->buffer_pointer + packet.fragmentation_header_shift(), packet.buffer + packet.payload_position, actual_payload_length );
						else
						{
// 							debug().debug( "DPS: DF %lx ST: %i P: %i", from, act_buffer->processed_size, packet.fragmentation_header_shift());
							DF_drop = true;
						}
					}
					else
					{
						memcpy( act_buffer->buffer_pointer, packet.buffer + packet.payload_position, actual_payload_length );
					}
					
					//Send back an ACK if it is requested by the sender, use the actual packet since the header has to be almost the same
					if( packet.ack_flag() )
					{
						packet.set_type( DPS_Packet_t::DPS_TYPE_RPC_ACK );
						packet.length = packet.payload_position;
#if DPS_FOOTER > 0
						packet.set_checksum( it, false );
#endif
						radio().send( it->partner_MAC, packet.length, packet.buffer );
					}
					
					if( DF_drop )
					{
						#if DPS_RADIO_DEBUG >= 1
						debug().debug( "DPS: OffsetDrop %lx %i", from, act_buffer->processed_size);
// 						debug().debug( "DPS duplicated fragment %i %i!", act_buffer->processed_size, packet.fragmentation_header_shift() );
						#endif
						return;
					}
					
					//NOTE this does not accept out of order arrival for fragments
					//Update the size
					act_buffer->processed_size += actual_payload_length;
					
					//Notify the the RPC_handler if the full RPC is here
					if( act_buffer->processed_size == act_buffer->buffer_length )
					{
#ifdef DPS_ENABLE_RPC_HEADER_COMPRESSION
					if( counter == &(it->server_counter) )
						(*counter) = (it->server_counter & 0xFFFFFF00) | packet_counter;
					else
						(*counter) = (it->client_counter & 0xFFFFFF00) | packet_counter;
#else
					//If the counter is not compressed, just get it from the packet
					(*counter) = packet_counter;
#endif
						
						(protocol_list_[packet.pid()].rpc_handler_delegate)( act_buffer->RPC_parameters, act_buffer->buffer_length, act_buffer->buffer_pointer );
						
						//Do not eresa here, because the last ACK can get lost, the timeout will delete the buffer
// 						buffer_list_.erase( act_buffer );
					}
// 						debug().debug( "RMEM: %i",  mem->mem_free() );
				}
				//else if ...
// 				{
// 					//TODO process RPC REPLY?
// 				}
			//-----------Connection setup messages----------
				else if( type == DPS_Packet_t::DPS_TYPE_ADVERTISE ) //CLIENT CODE
				{
					//If there is a connection drop the message
					if( it->connection_status != connection_type::SENDING_DISCOVERY )
						return;
					
					//If this is a better candidate than the previous ones, based on the link metric
					if( it->link_metric > ex.link_metric() )
					{
						//If this was the first advertisement, wait some more time for a possible better candidate
						if( it->link_metric == 0xFFFF )
						{
							int tmp = DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST << 8;
							tmp |= (it-connection_list_.begin());
							timer().template set_timer<self_type, &self_type::send_delayed_connection_message>( DPS_WAIT_FOR_MORE_ADVERTISEMENTS_TIMEOUT, this, (void*)(tmp) );
						}
						
						it->partner_MAC = from;
						it->link_metric = ex.link_metric();
						
						#if DPS_RADIO_DEBUG >= 1
						debug().debug( "DPS: candidate (%lx) stored with link_metric: %i", (from), it->link_metric );
						#endif
					}
				}
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
				else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST ) //SERVER CODE
				{
					it->connection_status = connection_type::ALLOW_SENT;
					send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW, it );
				}
#endif
				else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_ALLOW ) //CLIENT CODE
				{
					it->connection_status = connection_type::CONNECTED;
					it->server_counter = bitwise_read<OsModel, block_data_t, uint32_t>( payload, 0, 32 );
					
					#if DPS_RADIO_DEBUG >= 1
					debug().debug( "DPS: Client (%lx) connected to %lx, protocol: %i", (radio().id()), (from), it->Pid);
					debug().debug( "DPS CNT_c: %x, CNT_s: %x, nonce: %x", (it->client_counter), (it->server_counter), (it->connection_nonce) );
					#endif
					
					send_connection_message( from, DPS_Packet_t::DPS_TYPE_CONNECT_FINISH, it );
					
					//Call back the handler because of the new connection
					node_id_t tmp;
					tmp.Pid = it->Pid;
					tmp.Fid = NEW_CONNECTION;
					tmp.target_address = from;
					(protocol_list_[packet.pid()].rpc_handler_delegate)( tmp, 0, NULL );
				}
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
				else if( type == DPS_Packet_t::DPS_TYPE_CONNECT_FINISH ) //SERVER SIDE
				{
					it->connection_status = connection_type::CONNECTED;
					
					#if DPS_RADIO_DEBUG >= 1
					debug().debug( "DPS: Server (%lx) connected to %lx, protocol: %i", (radio().id()), (from), it->Pid);
					debug().debug( "DPS CNT_c: %x, CNT_s: %x, nonce: %x", (it->client_counter), (it->server_counter), (it->connection_nonce) );
					#endif
					
					//Call back the handler because of the new connection
					node_id_t tmp;
					tmp.Pid = it->Pid;
					tmp.Fid = NEW_CONNECTION;
					tmp.target_address = from;
					(protocol_list_[packet.pid()].rpc_handler_delegate)( tmp, 0, NULL );
				}
#endif
				//DPS_Packet_t::DPS_TYPE_CONNECT_ABORT + the non-implemented DISCONNECT messages
				else if ( type <= DPS_Packet_t::DPS_TYPE_DISCONNECT_FINISH )
				{
					connection_list_.erase( it );
				}
				return;
			}
		}
		#if DPS_RADIO_DEBUG >= 0
		debug().debug( "DPS MsgNoConn from %lx", from );
// 		debug().debug( "DPS: Error, (%lx) received from %lx, no conn!", (radio().id()), (from));
		#endif
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
		typename Radio_P,
		typename Debug_P,
		typename Timer_P,
		typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	send_delayed_connection_message( void* n_in )
	{
		int n = (int)n_in;
		
		Connection_list_iterator it = connection_list_.begin() + ( n & 0xFF );
		
		if( (n >> 8) == DPS_Packet_t::DPS_TYPE_DISCOVERY )
		{
			//NOTE may not the expected
			if( it->connection_status == connection_type::SENDING_DISCOVERY )
			{
				send_connection_message( Radio::BROADCAST_ADDRESS, DPS_Packet_t::DPS_TYPE_DISCOVERY, it );
				it->last_sent_timer += DPS_TIMER_DISCOVERY_FREQUENCY;
				timer().template set_timer<self_type, &self_type::send_delayed_connection_message>( DPS_TIMER_DISCOVERY_FREQUENCY, this, n_in );
			}
		}
		else //DPS_TYPE_CONNECT_REQUEST
		{
			it->connection_status = connection_type::CONNECT_SENT;
		
			//Send a CONNECT to the selected server 
			send_connection_message( it->partner_MAC, DPS_Packet_t::DPS_TYPE_CONNECT_REQUEST, it );
		}
	}
	
	// -----------------------------------------------------------------------
	template<typename OsModel_P,
	typename Radio_P,
	typename Debug_P,
	typename Timer_P,
	typename Rand_P>
	void
	DPS_Radio<OsModel_P, Radio_P, Debug_P, Timer_P, Rand_P>::
	general_periodic_timer( void* )
	{
#ifdef DPS_COLLECT_STATS
		if( stat_time % DPS_PRINT_STATS == 0 )
		{
			debug().debug("---STAT: UP: %i Reset#: %i DPSConn#: %i ACKResend#: %i BuffTimeout#: %i", stat_time/1000, reset_connection, connection_list_.size(), ACK_timeouts, buffer_timeouts);
// 			stat_time = 0;
		}
		stat_time += DPS_GENERAL_TIMER_FREQUENCY;
#endif
		
		for( Connection_list_iterator it = connection_list_.begin(); it != connection_list_.end(); ++it )
		{
			it->last_received_timer += DPS_GENERAL_TIMER_FREQUENCY;
			it->last_sent_timer += DPS_GENERAL_TIMER_FREQUENCY;
			
			bool client_restart_discovery = false;
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
			bool server_remove_connection = false;
#endif
			
			//The connection timeouts are only for established connections
			if(( it->connection_status == connection_type::CONNECTED ) )
			{
				//CONNECTED and ( HEARTBEAT_TIMEOUT <= elapsed_time < DELETE_TIMEOUT )
				if (( it->last_sent_timer >= DPS_HEARTBEAT_THRESHOLD ) && (it->last_received_timer < DPS_DELETE_CONNECTION_THRESHOLD))
				{
					send_connection_message( it->partner_MAC, DPS_Packet_t::DPS_TYPE_HEARTBEAT, it);
					continue;
				}
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
				//For the server
				if( (protocol_list_[it->Pid].server) )
					if( it->last_received_timer >= DPS_DELETE_CONNECTION_THRESHOLD )
						server_remove_connection = true;
					
				//For the client
				//The SENDING_DISCOVERY state is handled by another timer&function
				else
#endif
					if( it->last_received_timer >= DPS_DELETE_CONNECTION_THRESHOLD )
						client_restart_discovery = true;
			}
			//Remove entries which are not in connected state nor DISCOVERY
			else if( it->connection_status != connection_type::SENDING_DISCOVERY )
			{
				if( it->last_received_timer >= DPS_NON_CONNECTED_TIMEOUT )
				{
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
					if( (protocol_list_[it->Pid].server) )
						server_remove_connection = true;
					else
#endif
						client_restart_discovery = true;
				}
			}
			
#ifndef DPS_COMPILE_ONLY_CLIENT_CODES
			if( server_remove_connection )
			{
				#if DPS_RADIO_DEBUG >= 0
				debug().debug( "DPS: rm client (%lx/%i)", (it->partner_MAC), it->Pid);
				#endif
				
				//TODO check for buffer in use!
#ifdef DPS_COLLECT_STATS
				reset_connection++;
#endif
				
// 				//Call back the handler because of the died connection
				node_id_t tmp;
				tmp.Pid = it->Pid;
				tmp.Fid = DELETE_CONNECTION;
				tmp.target_address = it->partner_MAC;
				(protocol_list_[it->Pid].rpc_handler_delegate)( tmp, 0, NULL );
				
				//This is needed, because the erase copies the remaining part of the
				//list backward, and because of the loop we would be able to read
				//a non-existing item.
				Connection_list_iterator tmp_it = it - 1;
				connection_list_.erase( it );
				it = tmp_it;
				
				//Break the loop if this was the only element
				if( connection_list_.size() == 0 )
					break;
			}
#endif
			
			
			if( client_restart_discovery )
			{
				#if DPS_RADIO_DEBUG >= 0
				debug().debug( "DPS: reDISC (%lx/%i)", (it->partner_MAC), it->Pid);
				#endif
				
#ifdef DPS_COLLECT_STATS
				reset_connection++;
#endif
				
				//TODO check for buffer in use!
				
// 				//Call back the handler because of the died connection
				node_id_t node;
				node.Pid = it->Pid;
				node.Fid = DELETE_CONNECTION;
				node.target_address = it->partner_MAC;
				(protocol_list_[it->Pid].rpc_handler_delegate)( node, 0, NULL );
				
				it->connection_status = connection_type::SENDING_DISCOVERY;
				it->client_counter = rand()() % (0xFFFFFFFF);
				it->link_metric = 0xFFFF;
// 				it->server_counter = 0;
				it->partner_MAC = Radio::NULL_NODE_ID;
// 				it->connection_nonce = 0;
				
				int tmp = DPS_Packet_t::DPS_TYPE_DISCOVERY << 8;
				tmp |= (it-connection_list_.begin());
				timer().template set_timer<self_type, &self_type::send_delayed_connection_message>( DPS_TIMER_DISCOVERY_FREQUENCY, this, (void*)(tmp) );
			}
		}
		
		for( Buffer_list_iterator it = buffer_list_.begin(); it != buffer_list_.end(); ++it )
		{
			it->elapsed_time += DPS_GENERAL_TIMER_FREQUENCY;
			
			
			//Timeout for incoming packet || too many retries for an outgoing packet --> drop
			if( ( it->processed_size == it->buffer_length ) ||
				(!(it->outgoing) && ( it->elapsed_time > DPS_FRAGMENT_COLLECTION_TIMEOUT )) ||
				( it->transmission_retries >= DPS_ACK_MAX_RETRIES ))
			{
				//Free up the buffer
				(protocol_list_[it->RPC_parameters.Pid].buffer_handler_delegate)( it->buffer_pointer, it->buffer_length, false );
				
				//Sending uncompleted, increment the counter //NOTE ?
				
// #ifndef DPS_COMPILE_ONLY_CLIENT_CODES
// 				if( protocol_list_[it->connection_it->Pid].server )
// 					it->connection_it->server_counter++;
// 				else
// #endif
// 					it->connection_it->client_counter++;
			
#ifdef DPS_COLLECT_STATS
				if( it->processed_size != it->buffer_length )
					buffer_timeouts++;
#endif
				
#if DPS_RADIO_DEBUG >= 1
				if( it->processed_size != it->buffer_length )
					debug().debug( "DPS: Timeout rm buffer");
#endif
				
				Buffer_list_iterator tmp_it = it - 1;
				//remove from the list
				buffer_list_.erase( it );
				it = tmp_it;
			
				
				//Break the loop if this was the only element
				if( buffer_list_.size() == 0 )
					break;
			}
			else if( it->outgoing && ( it->elapsed_time > DPS_ACK_TIMEOUT ) )
			{
				#if DPS_RADIO_DEBUG >= 1
				debug().debug( "DPS: re-send fragment (%i/%i)", it->buffer_length, it->processed_size );
				#endif
				it->transmission_retries++;
				
#ifdef DPS_COLLECT_STATS
				ACK_timeouts++;
#endif
				
				send_RPC( it );
			}
		}
		
		
		timer().template set_timer<self_type, &self_type::general_periodic_timer>( DPS_GENERAL_TIMER_FREQUENCY, this, NULL );
	}
	
}
#endif
